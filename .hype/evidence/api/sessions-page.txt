<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="T_Vz9FBtv6a0bhOHo-5Fp_hKMbWAuQ0VuJJ-Ui__cKU">
    <title>Telegram Sessions - ChatFilter</title>
    <link rel="icon" type="image/x-icon" href="/static/images/logo.ico">
    <link rel="stylesheet" href="/static/css/style.css">
    <script src="/static/js/htmx.min.js"></script>
    <script src="/static/js/sse.js"></script>
    <script src="/static/js/hyperlist.min.js"></script>
    <script src="/static/js/chart.umd.min.js"></script>
    <script src="/static/js/i18n.js"></script>
    <script src="/static/js/language-switcher.js"></script>
    <script src="/static/js/theme-switcher.js"></script>
    <script src="/static/js/tab-sync.js"></script>
    <script src="/static/js/tab-activity.js"></script>
    <script src="/static/js/request-dedup.js"></script>
    <script src="/static/js/optimistic-lock.js"></script>
    <script src="/static/js/conflict-warnings.js"></script>
    <script src="/static/js/tooltips.js"></script>
    <script src="/static/js/virtual-chat-list.js"></script>
    <script src="/static/js/version-check.js"></script>
    <script src="/static/js/session-config.js"></script>
    
</head>
<body>
    <!-- Skip to main content link for keyboard navigation -->
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <header role="banner">
        <nav role="navigation" aria-label="Main navigation">
            <a href="/" class="logo">ChatFilter</a>
            <ul class="nav-links">
                <li><a href="/proxies" data-tooltip="Manage proxy servers for Telegram sessions" data-tooltip-position="bottom">Proxies</a></li>
                <li><a href="/" data-tooltip="Manage your Telegram session files" data-tooltip-position="bottom">Sessions</a></li>
                <li><a href="/chats" data-tooltip="Select chats to analyze from your Telegram account" data-tooltip-position="bottom">Chats</a></li>
                <li><a href="/chatlist" data-tooltip="Import a list of chats from a file or Google Sheets" data-tooltip-position="bottom">Import</a></li>
                <li><a href="/results" data-tooltip="View analysis results and export data" data-tooltip-position="bottom">Results</a></li>
                <li><a href="/history" data-tooltip="Browse your past analysis history" data-tooltip-position="bottom">History</a></li>
            </ul>
            <div class="status-indicators">
                <div class="network-status" id="network-status" role="status" aria-live="polite" data-tooltip="Shows your internet connection status" data-tooltip-position="bottom">
                    <span class="status-indicator" id="network-indicator" aria-hidden="true"></span>
                    <span class="status-text" id="network-text">Online</span>
                </div>
                <button id="theme-toggle" class="theme-toggle-btn" aria-label="Toggle dark mode" data-tooltip="Switch between light and dark theme" data-tooltip-position="bottom">
                    <span class="theme-icon" aria-hidden="true">üåô</span>
                </button>
                <button id="language-toggle" class="language-toggle-btn" aria-label="Switch language" data-tooltip="Switch between English and Russian" data-tooltip-position="bottom">
                    <span class="language-icon" aria-hidden="true">EN</span>
                </button>
            </div>
        </nav>
    </header>

    <!-- SSE Connection Status Banner (hidden by default, shown on connection failure) -->
    <div id="sse-status-banner" class="sse-status-banner" role="alert" aria-live="assertive" style="display: none;">
        <div class="banner-content">
            <span class="banner-icon" aria-hidden="true">‚ö†</span>
            <div class="banner-message">
                <strong>Real-time updates paused</strong>
                <span>Connection lost. Please refresh to restore live status updates.</span>
            </div>
            <button class="banner-action" onclick="window.location.reload()" aria-label="Refresh page to reconnect">
                Refresh Now
            </button>
            <button class="banner-close" onclick="SSEStatusBanner.hide()" aria-label="Dismiss banner">
                &times;
            </button>
        </div>
    </div>

    <main id="main-content" role="main">
        
<div class="page-header">
    <h1>Telegram Accounts</h1>
    <p class="subtitle">Manage your Telegram sessions for chat analysis</p>
</div>

<section class="card">
    <div class="card-header-actions">
        <h2>Accounts</h2>
        <button class="btn btn-primary" id="add-account-btn" aria-label="Add new account">
            + Add Account
        </button>
    </div>

    <div id="sessions-list"
         hx-get="/api/sessions"
         hx-trigger="load, refreshSessions from:body"
         hx-swap="innerHTML"
         hx-on:htmx:response-error="this.innerHTML = '<div class=\'alert alert-error\'><strong>Error:</strong> Failed to load accounts. Please refresh the page.</div>'"
         role="region"
         aria-live="polite"
         aria-label="List of Telegram accounts">
        <div class="skeleton-container" aria-busy="true" role="status">
            <span class="skeleton-sr-text">Loading accounts...</span>
            <div class="skeleton-accounts-table">
                <div class="skeleton skeleton-row"></div>
                <div class="skeleton skeleton-row"></div>
                <div class="skeleton skeleton-row"></div>
            </div>
        </div>
    </div>
</section>


<div class="modal-overlay" id="add-account-modal" role="dialog" aria-modal="true" aria-labelledby="add-account-title">
    <div class="modal-dialog modal-dialog-form modal-lg">
        <div class="modal-header">
            <h2 class="modal-title" id="add-account-title">Add Telegram Account</h2>
            <button class="modal-close-btn" id="close-add-account-modal" aria-label="Close modal">&times;</button>
        </div>

        <div class="modal-tabs">
            <button class="modal-tab active" data-tab="phone-auth" aria-selected="true">
                Phone Authorization
            </button>
            <button class="modal-tab" data-tab="upload-session" aria-selected="false">
                Upload Session
            </button>
        </div>

        <div class="modal-body">
            
            <div class="tab-content active" id="tab-phone-auth">
                <p class="tab-description">Authenticate with your phone number to create a new session.</p>

                <div id="auth-form-container"
                     hx-get="/api/sessions/auth/form"
                     hx-trigger="modal-opened"
                     hx-swap="innerHTML">
                    <div class="skeleton-container" aria-busy="true">
                        <div class="skeleton skeleton-form" style="height: 280px;"></div>
                    </div>
                </div>
            </div>

            
            <div class="tab-content" id="tab-upload-session">
                <p class="tab-description">Already have a .session file? Upload it here with your API credentials.</p>

                <div id="session-import-container">
                    
<div id="session-import-container">
    
    <div id="import-step-file" class="import-step">
        <div class="import-file-form">
            <div class="form-group">
                <label for="session-file-input">Session File (.session) <span class="required">*</span></label>
                <input type="file"
                       id="session-file-input"
                       name="session_file"
                       accept=".session"
                       required>
                <small class="form-hint">Select your Telegram session file</small>
                <div id="session-file-info" class="file-info" style="display: none; margin-top: 0.5rem;"></div>
            </div>

            <div class="form-group">
                <label for="json-file-input">Account Info (.json) <span class="required">*</span></label>
                <input type="file"
                       id="json-file-input"
                       name="json_file"
                       accept=".json"
                       required>
                <small class="form-hint">JSON file with phone and 2FA (TelegramExpert format)</small>
                <div id="json-file-info" class="file-info" style="display: none; margin-top: 0.5rem;"></div>
            </div>

            <div id="import-file-error" class="alert alert-error" style="display: none;"></div>

            <button type="button" id="validate-files-btn" class="btn btn-primary" disabled>
                Validate and Continue
            </button>
        </div>

        <div id="import-validation-result"></div>
    </div>

    
    <div id="import-step-config" class="import-step" style="display: none;">
        <div class="alert alert-info">
            <strong>Session files validated successfully!</strong>
            Now configure the session settings below.
        </div>

        <form id="session-config-form"
              hx-post="/api/sessions/import/save"
              hx-encoding="multipart/form-data"
              hx-target="#import-save-result"
              hx-swap="innerHTML"
              hx-indicator="#save-spinner">

            <input type="hidden" id="validated-session-data" name="session_data" value="">

            <div class="form-group">
                <label for="import-session-name"
                       data-tooltip="A unique identifier for this Telegram session"
                       data-tooltip-position="right">Session Name</label>
                <input type="text"
                       id="import-session-name"
                       name="session_name"
                       required
                       placeholder="e.g., my_account"
                       pattern="[a-zA-Z0-9_-]+"
                       aria-describedby="import-session-name-hint"
                       aria-required="true">
                <small id="import-session-name-hint" class="form-hint">A unique name to identify this session. Only letters, numbers, underscores, and hyphens allowed.</small>
            </div>

            <div class="import-config-form">
                <div class="form-row">
                    <div class="form-group">
                        <label for="import-api-id"
                               data-tooltip="Your Telegram API ID from my.telegram.org"
                               data-tooltip-position="right">API ID</label>
                        <input type="number"
                               id="import-api-id"
                               name="api_id"
                               placeholder="e.g., 12345678"
                               min="1"
                               aria-describedby="import-api-id-hint">
                        <small id="import-api-id-hint" class="form-hint">Numeric ID from my.telegram.org/apps (optional)</small>
                    </div>

                    <div class="form-group">
                        <label for="import-api-hash"
                               data-tooltip="Your Telegram API Hash from my.telegram.org"
                               data-tooltip-position="right">API Hash</label>
                        <input type="text"
                               id="import-api-hash"
                               name="api_hash"
                               placeholder="e.g., 0123456789abcdef..."
                               pattern="[a-fA-F0-9]+"
                               minlength="32"
                               maxlength="32"
                               aria-describedby="import-api-hash-hint">
                        <small id="import-api-hash-hint" class="form-hint">32-character hex string from my.telegram.org/apps (optional)</small>
                    </div>
                </div>

                <div class="form-group">
                    <label for="import-proxy-id"
                           data-tooltip="Select a proxy for this session"
                           data-tooltip-position="right">Proxy</label>
                    <select id="import-proxy-id"
                            name="proxy_id"
                            aria-describedby="import-proxy-id-hint">
                        <option value="">-- Select a proxy --</option>
                        
                        
                        <option value="b80b5291-0647-4d40-a406-f84bad47d306" class="proxy-option-disabled">
                            &#x1F534; Default (unavailable)
                        </option>
                        
                        
                    </select>
                    <small id="import-proxy-id-hint" class="form-hint">
                        Optional: Select a proxy for Telegram connection.
                        
                    </small>
                </div>

                <div class="form-group">
                    <label for="import-security-acknowledgment" style="display: flex; align-items: flex-start; cursor: pointer; user-select: none;">
                        <input type="checkbox"
                               id="import-security-acknowledgment"
                               name="security_acknowledgment"
                               required
                               aria-required="true"
                               style="margin-right: 0.5rem; margin-top: 0.25rem; cursor: pointer;">
                        <span>I understand that session files provide complete access to my Telegram account and accept the security risks. I confirm this session was created on a trusted device and will be stored securely.</span>
                    </label>
                </div>
            </div>

            <div class="form-actions" style="display: flex; gap: 1rem; flex-wrap: wrap;">
                <button type="button" class="btn btn-secondary" id="import-back-btn">
                    Back
                </button>
                <button type="submit" class="btn btn-primary" id="import-save-btn">
                    <span class="btn-text">Save Session</span>
                    <span id="save-spinner" class="htmx-indicator spinner" role="status" aria-live="polite"></span>
                </button>
            </div>
        </form>

        <div id="import-save-result" role="region" aria-live="polite" aria-atomic="true"></div>
    </div>
</div>

<script>
(function() {
    const sessionFileInput = document.getElementById('session-file-input');
    const jsonFileInput = document.getElementById('json-file-input');
    const sessionFileInfo = document.getElementById('session-file-info');
    const jsonFileInfo = document.getElementById('json-file-info');
    const errorDiv = document.getElementById('import-file-error');
    const validateBtn = document.getElementById('validate-files-btn');
    const validationResult = document.getElementById('import-validation-result');

    const stepFile = document.getElementById('import-step-file');
    const stepConfig = document.getElementById('import-step-config');
    const sessionNameInput = document.getElementById('import-session-name');
    const backBtn = document.getElementById('import-back-btn');
    const configForm = document.getElementById('session-config-form');

    let selectedSessionFile = null;
    let selectedJsonFile = null;

    // Format file size
    function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    // Show error
    function showError(message) {
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
    }

    // Clear error
    function clearError() {
        errorDiv.style.display = 'none';
    }

    // Update button state
    function updateValidateButton() {
        validateBtn.disabled = !selectedSessionFile || !selectedJsonFile;
    }

    // Display file info
    function displayFileInfo(file, infoDiv) {
        infoDiv.textContent = `${file.name} (${formatFileSize(file.size)})`;
        infoDiv.style.display = 'block';
    }

    // Handle session file selection
    sessionFileInput.addEventListener('change', () => {
        clearError();
        if (sessionFileInput.files.length > 0) {
            const file = sessionFileInput.files[0];
            if (!file.name.endsWith('.session')) {
                showError('Invalid file type. Please select a .session file.');
                sessionFileInput.value = '';
                sessionFileInfo.style.display = 'none';
                selectedSessionFile = null;
            } else {
                selectedSessionFile = file;
                displayFileInfo(file, sessionFileInfo);
            }
        } else {
            selectedSessionFile = null;
            sessionFileInfo.style.display = 'none';
        }
        updateValidateButton();
    });

    // Handle JSON file selection
    jsonFileInput.addEventListener('change', () => {
        clearError();
        if (jsonFileInput.files.length > 0) {
            const file = jsonFileInput.files[0];
            if (!file.name.endsWith('.json')) {
                showError('Invalid file type. Please select a .json file.');
                jsonFileInput.value = '';
                jsonFileInfo.style.display = 'none';
                selectedJsonFile = null;
            } else {
                selectedJsonFile = file;
                displayFileInfo(file, jsonFileInfo);
            }
        } else {
            selectedJsonFile = null;
            jsonFileInfo.style.display = 'none';
        }
        updateValidateButton();
    });

    // Validate files on server
    validateBtn.addEventListener('click', async () => {
        if (!selectedSessionFile || !selectedJsonFile) {
            showError('Please select both files.');
            return;
        }

        clearError();
        const formData = new FormData();
        formData.append('session_file', selectedSessionFile);
        formData.append('json_file', selectedJsonFile);

        validationResult.innerHTML = '<div class="alert alert-info">Validating files...</div>';
        validateBtn.disabled = true;

        try {
            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
            const response = await fetch('/api/sessions/import/validate', {
                method: 'POST',
                headers: {
                    'X-CSRF-Token': csrfToken
                },
                body: formData
            });

            const html = await response.text();
            validationResult.innerHTML = html;

            if (response.ok) {
                // Auto-suggest session name from filename
                const suggestedName = selectedSessionFile.name.replace(/\.session$/, '').replace(/[^a-zA-Z0-9_-]/g, '_');
                if (suggestedName) {
                    sessionNameInput.value = suggestedName;
                }

                // Store files for later submission
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(selectedSessionFile);
                let hiddenSessionInput = document.getElementById('config-session-file');
                if (!hiddenSessionInput) {
                    hiddenSessionInput = document.createElement('input');
                    hiddenSessionInput.type = 'file';
                    hiddenSessionInput.id = 'config-session-file';
                    hiddenSessionInput.name = 'session_file';
                    hiddenSessionInput.style.display = 'none';
                    configForm.appendChild(hiddenSessionInput);
                }
                hiddenSessionInput.files = dataTransfer.files;

                const jsonTransfer = new DataTransfer();
                jsonTransfer.items.add(selectedJsonFile);
                let hiddenJsonInput = document.getElementById('config-json-file');
                if (!hiddenJsonInput) {
                    hiddenJsonInput = document.createElement('input');
                    hiddenJsonInput.type = 'file';
                    hiddenJsonInput.id = 'config-json-file';
                    hiddenJsonInput.name = 'json_file';
                    hiddenJsonInput.style.display = 'none';
                    configForm.appendChild(hiddenJsonInput);
                }
                hiddenJsonInput.files = jsonTransfer.files;

                // Show config step after short delay
                setTimeout(() => {
                    stepFile.style.display = 'none';
                    stepConfig.style.display = 'block';
                    sessionNameInput.focus();
                }, 500);
            } else {
                validateBtn.disabled = false;
            }
        } catch (error) {
            validationResult.innerHTML = '<div class="alert alert-error">Failed to validate files. Please try again.</div>';
            validateBtn.disabled = false;
            console.error('Validation error:', error);
        }
    });

    // Back button
    backBtn.addEventListener('click', () => {
        stepConfig.style.display = 'none';
        stepFile.style.display = 'block';
        validateBtn.disabled = false;
    });

    // Handle form submission success
    document.body.addEventListener('htmx:afterSwap', (e) => {
        if (e.detail.target.id === 'import-save-result') {
            const resultDiv = e.detail.target;
            if (resultDiv.querySelector('.alert-success')) {
                // Clear form and reset
                sessionFileInput.value = '';
                jsonFileInput.value = '';
                selectedSessionFile = null;
                selectedJsonFile = null;
                sessionFileInfo.style.display = 'none';
                jsonFileInfo.style.display = 'none';
                configForm.reset();
                stepConfig.style.display = 'none';
                stepFile.style.display = 'block';
                updateValidateButton();

                // Refresh sessions list
                const sessionsList = document.getElementById('sessions-list');
                if (sessionsList && typeof htmx !== 'undefined') {
                    htmx.trigger(sessionsList, 'refreshSessions');
                }
            }
        }
    });
})();
</script>
                </div>
            </div>
        </div>
    </div>
</div>

    </main>
    <footer role="contentinfo">
        <p>ChatFilter v0.8.2</p>
        <div class="footer-actions">
            <a href="/api/export/diagnostics?format=text"
               download
               class="diagnostic-button"
               aria-label="Export diagnostic information for troubleshooting">
                Export Diagnostics
            </a>
        </div>
    </footer>

    <!-- Toast notification container with ARIA live region -->
    <div id="toast-container" role="alert" aria-live="assertive" aria-atomic="true"></div>

    <!-- Modal container for HTMX-loaded modals -->
    <div id="modal-container"></div>

    <!-- CSRF Token Configuration for HTMX -->
    <script>
        // Configure HTMX to include CSRF token in all POST/DELETE requests
        document.addEventListener('DOMContentLoaded', function() {
            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;

            if (csrfToken) {
                // Add CSRF token to all HTMX requests
                document.body.addEventListener('htmx:configRequest', function(event) {
                    // Only add token to POST/PUT/DELETE requests
                    if (event.detail.verb === 'post' || event.detail.verb === 'put' || event.detail.verb === 'delete') {
                        event.detail.headers['X-CSRF-Token'] = csrfToken;
                    }
                });
            } else {
                console.warn('CSRF token not found in page meta tags');
            }
        });
    </script>

    <!-- Global error handling and toast system -->
    <script>
        // Toast Notification System
        const ToastManager = {
            container: null,
            queue: [],
            maxToasts: 3,
            defaultDuration: 5000,

            init() {
                this.container = document.getElementById('toast-container');
                if (!this.container) {
                    this.container = document.createElement('div');
                    this.container.id = 'toast-container';
                    document.body.appendChild(this.container);
                }
            },

            show(options) {
                if (!this.container) this.init();

                const toast = {
                    id: Date.now() + Math.random(),
                    type: options.type || 'info',
                    title: options.title || this.getDefaultTitle(options.type),
                    message: options.message || '',
                    duration: options.duration !== undefined ? options.duration : this.defaultDuration,
                    actions: options.actions || [],
                    onClose: options.onClose
                };

                this.queue.push(toast);
                this.render();

                if (toast.duration > 0) {
                    setTimeout(() => this.hide(toast.id), toast.duration);
                }

                return toast.id;
            },

            hide(toastId) {
                const toast = this.queue.find(t => t.id === toastId);
                if (!toast) return;

                const element = document.querySelector(`[data-toast-id="${toastId}"]`);
                if (element) {
                    element.classList.add('hiding');
                    setTimeout(() => {
                        this.queue = this.queue.filter(t => t.id !== toastId);
                        this.render();
                        if (toast.onClose) toast.onClose();
                    }, 300);
                }
            },

            hideAll() {
                const toastIds = this.queue.map(t => t.id);
                toastIds.forEach(id => this.hide(id));
            },

            render() {
                const visibleToasts = this.queue.slice(-this.maxToasts);
                this.container.innerHTML = visibleToasts.map(toast => this.createToastHTML(toast)).join('');

                setTimeout(() => {
                    visibleToasts.forEach(toast => {
                        const element = document.querySelector(`[data-toast-id="${toast.id}"]`);
                        if (element) element.classList.add('show');
                    });
                }, 10);
            },

            createToastHTML(toast) {
                const icons = {
                    error: '‚úï',
                    success: '‚úì',
                    warning: '‚ö†',
                    info: '‚Ñπ'
                };

                const iconLabels = {
                    error: 'Error',
                    success: 'Success',
                    warning: 'Warning',
                    info: 'Information'
                };

                const actionsHTML = toast.actions.length > 0 ? `
                    <div class="toast-actions">
                        ${toast.actions.map(action => `
                            <button class="toast-action ${action.class || ''}"
                                    onclick="ToastManager.handleAction('${toast.id}', '${action.action}')"
                                    aria-label="${this.escapeHtml(action.label)}">
                                ${action.label}
                            </button>
                        `).join('')}
                    </div>
                ` : '';

                return `
                    <div class="toast toast-${toast.type}" data-toast-id="${toast.id}" role="alert" aria-live="assertive">
                        <div class="toast-icon" aria-label="${iconLabels[toast.type] || iconLabels.info}" role="img">${icons[toast.type] || icons.info}</div>
                        <div class="toast-content">
                            <div class="toast-title">${this.escapeHtml(toast.title)}</div>
                            ${toast.message ? `<div class="toast-message">${this.escapeHtml(toast.message)}</div>` : ''}
                            ${actionsHTML}
                        </div>
                        <button class="toast-close" onclick="ToastManager.hide('${toast.id}')" aria-label="Close notification">&times;</button>
                    </div>
                `;
            },

            handleAction(toastId, action) {
                const toast = this.queue.find(t => t.id === toastId);
                if (!toast) return;

                const actionObj = toast.actions.find(a => a.action === action);
                if (actionObj && actionObj.callback) {
                    actionObj.callback();
                }

                this.hide(toastId);
            },

            getDefaultTitle(type) {
                const titles = {
                    error: 'Error',
                    success: 'Success',
                    warning: 'Warning',
                    info: 'Info'
                };
                return titles[type] || 'Notification';
            },

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            // Convenience methods
            error(message, options = {}) {
                return this.show({ ...options, type: 'error', message });
            },

            success(message, options = {}) {
                return this.show({ ...options, type: 'success', message });
            },

            warning(message, options = {}) {
                return this.show({ ...options, type: 'warning', message });
            },

            info(message, options = {}) {
                return this.show({ ...options, type: 'info', message });
            }
        };

        // Initialize toast system
        ToastManager.init();

        // Global error boundary
        window.addEventListener('error', function(event) {
            console.error('Global error caught:', event.error);

            ToastManager.error(
                event.error?.message || 'An unexpected error occurred',
                {
                    title: 'Application Error',
                    duration: 0,
                    actions: [{
                        label: 'Reload Page',
                        class: 'retry',
                        action: 'reload',
                        callback: () => window.location.reload()
                    }, {
                        label: 'Dismiss',
                        class: 'dismiss',
                        action: 'dismiss'
                    }]
                }
            );
        });

        // Global unhandled promise rejection handler
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);

            ToastManager.error(
                event.reason?.message || 'An unexpected error occurred',
                {
                    title: 'Application Error',
                    duration: 8000
                }
            );
        });

        // Make ToastManager globally accessible
        window.ToastManager = ToastManager;

        // Modal Dialog System
        const ModalManager = {
            currentModal: null,
            overlayElement: null,

            init() {
                // Create modal overlay container if it doesn't exist
                this.overlayElement = document.getElementById('modal-overlay');
                if (!this.overlayElement) {
                    this.overlayElement = document.createElement('div');
                    this.overlayElement.id = 'modal-overlay';
                    this.overlayElement.className = 'modal-overlay';
                    this.overlayElement.setAttribute('role', 'dialog');
                    this.overlayElement.setAttribute('aria-modal', 'true');
                    document.body.appendChild(this.overlayElement);
                }

                // Close modal on overlay click
                this.overlayElement.addEventListener('click', (e) => {
                    if (e.target === this.overlayElement) {
                        this.hide();
                    }
                });

                // Close modal on Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.currentModal) {
                        this.hide();
                    }
                });
            },

            confirm(options) {
                return new Promise((resolve) => {
                    if (!this.overlayElement) this.init();

                    const modal = {
                        id: Date.now() + Math.random(),
                        type: options.type || 'warning',
                        icon: options.icon || this.getDefaultIcon(options.type),
                        title: options.title || 'Confirm Action',
                        message: options.message || 'Are you sure?',
                        confirmText: options.confirmText || 'Confirm',
                        cancelText: options.cancelText || 'Cancel',
                        confirmClass: options.confirmClass || 'danger',
                        onConfirm: () => {
                            resolve(true);
                            this.hide();
                        },
                        onCancel: () => {
                            resolve(false);
                            this.hide();
                        }
                    };

                    this.currentModal = modal;
                    this.render(modal);
                });
            },

            getDefaultIcon(type) {
                const icons = {
                    warning: '‚ö†Ô∏è',
                    danger: '‚õî',
                    info: '‚ÑπÔ∏è'
                };
                return icons[type] || icons.warning;
            },

            render(modal) {
                const modalHTML = `
                    <div class="modal-dialog" role="document">
                        <div class="modal-header">
                            <span class="modal-icon ${modal.type}" aria-hidden="true">${modal.icon}</span>
                            <h2 class="modal-title" id="modal-title-${modal.id}">${this.escapeHtml(modal.title)}</h2>
                        </div>
                        <div class="modal-body">
                            <p class="modal-message">${this.escapeHtml(modal.message)}</p>
                        </div>
                        <div class="modal-footer">
                            <button class="modal-button secondary"
                                    onclick="ModalManager.currentModal.onCancel()"
                                    aria-label="${this.escapeHtml(modal.cancelText)}">
                                ${this.escapeHtml(modal.cancelText)}
                            </button>
                            <button class="modal-button ${modal.confirmClass}"
                                    onclick="ModalManager.currentModal.onConfirm()"
                                    aria-label="${this.escapeHtml(modal.confirmText)}"
                                    autofocus>
                                ${this.escapeHtml(modal.confirmText)}
                            </button>
                        </div>
                    </div>
                `;

                this.overlayElement.innerHTML = modalHTML;
                this.overlayElement.setAttribute('aria-labelledby', `modal-title-${modal.id}`);

                // Show modal with animation
                setTimeout(() => {
                    this.overlayElement.classList.add('show');
                    // Focus the confirm button for accessibility
                    const confirmButton = this.overlayElement.querySelector('.modal-button.' + modal.confirmClass);
                    if (confirmButton) {
                        confirmButton.focus();
                    }
                }, 10);

                // Trap focus within modal
                this.trapFocus(this.overlayElement);
            },

            hide() {
                if (!this.overlayElement) return;

                this.overlayElement.classList.remove('show');

                setTimeout(() => {
                    this.overlayElement.innerHTML = '';
                    this.currentModal = null;
                }, 300);
            },

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            trapFocus(element) {
                const focusableElements = element.querySelectorAll(
                    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
                );

                if (focusableElements.length === 0) return;

                const firstFocusable = focusableElements[0];
                const lastFocusable = focusableElements[focusableElements.length - 1];

                element.addEventListener('keydown', function(e) {
                    if (e.key !== 'Tab') return;

                    if (e.shiftKey) {
                        if (document.activeElement === firstFocusable) {
                            lastFocusable.focus();
                            e.preventDefault();
                        }
                    } else {
                        if (document.activeElement === lastFocusable) {
                            firstFocusable.focus();
                            e.preventDefault();
                        }
                    }
                });
            }
        };

        // Initialize modal system
        ModalManager.init();

        // Make ModalManager globally accessible
        window.ModalManager = ModalManager;

        // HTMX Error Handling Configuration
        document.body.addEventListener('htmx:responseError', function(event) {
            const status = event.detail.xhr.status;
            const statusText = event.detail.xhr.statusText;
            let message = 'An error occurred while processing your request';
            let title = 'Request Failed';

            // Parse error response if JSON
            try {
                const response = JSON.parse(event.detail.xhr.responseText);
                if (response.detail) {
                    message = response.detail;
                }
            } catch (e) {
                // If not JSON, use status text
                if (status === 404) {
                    message = 'The requested resource was not found';
                    title = 'Not Found';
                } else if (status === 403) {
                    message = 'You do not have permission to access this resource';
                    title = 'Access Denied';
                } else if (status === 422) {
                    message = 'Invalid input. Please check your data and try again';
                    title = 'Validation Error';
                } else if (status >= 500) {
                    message = 'A server error occurred. Please try again later';
                    title = 'Server Error';
                } else if (statusText) {
                    message = statusText;
                }
            }

            // Get the retry action if available
            const target = event.detail.target;
            const canRetry = target && (target.tagName === 'FORM' || target.hasAttribute('hx-get') || target.hasAttribute('hx-post'));

            const actions = [];
            if (canRetry) {
                actions.push({
                    label: 'Retry',
                    class: 'retry',
                    action: 'retry',
                    callback: () => {
                        htmx.trigger(target, target.tagName === 'FORM' ? 'submit' : 'click');
                    }
                });
            }
            actions.push({
                label: 'Dismiss',
                class: 'dismiss',
                action: 'dismiss'
            });

            ToastManager.error(message, {
                title: title,
                duration: 8000,
                actions: actions
            });
        });

        // HTMX network error (timeout, connection failed, etc.)
        document.body.addEventListener('htmx:sendError', function(event) {
            const target = event.detail.target;
            const canRetry = target && (target.tagName === 'FORM' || target.hasAttribute('hx-get') || target.hasAttribute('hx-post'));

            const actions = [];
            if (canRetry) {
                actions.push({
                    label: 'Retry',
                    class: 'retry',
                    action: 'retry',
                    callback: () => {
                        htmx.trigger(target, target.tagName === 'FORM' ? 'submit' : 'click');
                    }
                });
            }
            actions.push({
                label: 'Dismiss',
                class: 'dismiss',
                action: 'dismiss'
            });

            ToastManager.error(
                'Unable to connect to the server. Please check your internet connection',
                {
                    title: 'Connection Error',
                    duration: 8000,
                    actions: actions
                }
            );
        });

        // HTMX timeout error
        document.body.addEventListener('htmx:timeout', function(event) {
            const target = event.detail.target;
            const canRetry = target && (target.tagName === 'FORM' || target.hasAttribute('hx-get') || target.hasAttribute('hx-post'));

            const actions = [];
            if (canRetry) {
                actions.push({
                    label: 'Retry',
                    class: 'retry',
                    action: 'retry',
                    callback: () => {
                        htmx.trigger(target, target.tagName === 'FORM' ? 'submit' : 'click');
                    }
                });
            }
            actions.push({
                label: 'Dismiss',
                class: 'dismiss',
                action: 'dismiss'
            });

            ToastManager.error(
                'The request took too long to complete. The server may be busy',
                {
                    title: 'Request Timeout',
                    duration: 8000,
                    actions: actions
                }
            );
        });

        // Cancel HTMX swap if target element was already replaced by SSE OOB swap.
        // When SSE OOB and HTMX response both target the same element, the SSE swap
        // replaces the DOM node first, leaving the HTMX response targeting a detached
        // element. Without this guard, htmx throws "Cannot read properties of null
        // (reading 'querySelector')" during outerHTML swap on the detached node.
        document.body.addEventListener('htmx:beforeSwap', function(event) {
            var target = event.detail.target;
            if (target && !target.isConnected) {
                console.log('HTMX swap cancelled: target already replaced by SSE');
                event.detail.shouldSwap = false;
            }
        });

        // HTMX swap error (invalid response format)
        document.body.addEventListener('htmx:swapError', function(event) {
            var target = event.detail.target;
            if (target && !target.isConnected) {
                // Race condition: SSE OOB swap already replaced the element
                console.log('HTMX swap race (suppressed): target already replaced by SSE');
                return;
            }

            console.error('HTMX swap error:', event.detail);

            ToastManager.error(
                'The server returned an unexpected response format',
                {
                    title: 'Response Error',
                    duration: 8000
                }
            );
        });

        // Log successful responses (optional, for debugging)
        // document.body.addEventListener('htmx:afterSwap', function(event) {
        //     console.log('HTMX swap successful:', event.detail);
        // });
    </script>

    <!-- Network Connectivity Status Monitor -->
    <script>
        const NetworkStatusMonitor = {
            pollInterval: 30000, // Poll every 30 seconds (less frequent than Telegram)
            timeoutId: null,
            lastStatus: null,
            consecutiveErrors: 0,
            maxErrors: 2,
            isOnline: true,

            async checkStatus() {
                try {
                    const response = await fetch('/health', {
                        method: 'GET',
                        cache: 'no-cache',
                        signal: AbortSignal.timeout(5000) // 5 second timeout
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const data = await response.json();
                    this.consecutiveErrors = 0;

                    const networkOnline = data.network && data.network.online;
                    this.updateUI(networkOnline, null);
                    this.notifyStatusChange(networkOnline);

                } catch (error) {
                    console.error('Network status check failed:', error);
                    this.consecutiveErrors++;

                    // After multiple failures, assume offline
                    if (this.consecutiveErrors >= this.maxErrors) {
                        this.updateUI(false, 'Unable to reach server');
                        this.notifyStatusChange(false);
                    }
                }

                // Schedule next poll
                this.timeoutId = setTimeout(() => this.checkStatus(), this.pollInterval);
            },

            updateUI(online, error) {
                const indicator = document.getElementById('network-indicator');
                const text = document.getElementById('network-text');
                const container = document.getElementById('network-status');

                if (!indicator || !text || !container) return;

                // Remove all status classes
                container.classList.remove('status-connected', 'status-disconnected', 'status-error');

                if (error) {
                    // Error state (offline)
                    container.classList.add('status-error');
                    text.textContent = window.i18n.t('status.offline');
                    container.title = `${window.i18n.t('status.network_disconnected')}: ${error}`;
                } else if (online) {
                    // Online state
                    container.classList.add('status-connected');
                    text.textContent = window.i18n.t('status.online');
                    container.title = window.i18n.t('status.network_connected');
                } else {
                    // Offline state
                    container.classList.add('status-disconnected');
                    text.textContent = window.i18n.t('status.offline');
                    container.title = window.i18n.t('status.network_disconnected');
                }
            },

            notifyStatusChange(isOnline) {
                // Only notify on actual state changes
                if (this.lastStatus === null) {
                    this.lastStatus = isOnline;
                    return;
                }

                if (this.lastStatus !== isOnline) {
                    if (!isOnline) {
                        // Network went offline
                        ToastManager.error(
                            'Please check your internet connection. Operations may fail until connectivity is restored.',
                            {
                                title: 'Network Offline',
                                duration: 0, // Persist until dismissed or network restored
                                actions: [{
                                    label: 'Check Now',
                                    class: 'retry',
                                    action: 'check',
                                    callback: () => this.checkStatus()
                                }, {
                                    label: 'Dismiss',
                                    class: 'dismiss',
                                    action: 'dismiss'
                                }]
                            }
                        );

                        // Broadcast to other tabs
                        if (typeof TabSync !== 'undefined') {
                            TabSync.broadcast('network-status', { online: false });
                        }
                    } else {
                        // Network came back online
                        ToastManager.success(
                            'Network connectivity restored',
                            {
                                title: 'Back Online',
                                duration: 3000
                            }
                        );

                        // Broadcast to other tabs
                        if (typeof TabSync !== 'undefined') {
                            TabSync.broadcast('network-status', { online: true });
                        }
                    }
                }

                this.lastStatus = isOnline;
            },

            start() {
                console.log('Starting network status monitor');
                this.checkStatus();

                // Also monitor browser online/offline events
                window.addEventListener('online', () => {
                    console.log('Browser reports: online');
                    this.checkStatus(); // Verify with server
                });

                window.addEventListener('offline', () => {
                    console.log('Browser reports: offline');
                    this.updateUI(false, 'No internet connection');
                    this.notifyStatusChange(false);
                });

                // Listen for status updates from other tabs
                if (typeof TabSync !== 'undefined') {
                    TabSync.on('network-status', (data) => {
                        console.log('Received network status update from another tab:', data);
                        this.checkStatus(); // Verify
                    });
                }
            },

            stop() {
                console.log('Stopping network status monitor');
                if (this.timeoutId) {
                    clearTimeout(this.timeoutId);
                    this.timeoutId = null;
                }
            }
        };

        // Start monitoring when page loads
        document.addEventListener('DOMContentLoaded', function() {
            NetworkStatusMonitor.start();
        });

        // Stop monitoring when page unloads
        window.addEventListener('beforeunload', function() {
            NetworkStatusMonitor.stop();
        });

        // Handle page visibility changes
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                NetworkStatusMonitor.stop();
            } else {
                NetworkStatusMonitor.start();
            }
        });

        // Make monitor globally accessible
        window.NetworkStatusMonitor = NetworkStatusMonitor;
    </script>

    <!-- SSE Connection Status Banner Manager -->
    <script>
        const SSEStatusBanner = {
            banner: null,
            visible: false,

            init() {
                this.banner = document.getElementById('sse-status-banner');
            },

            show() {
                if (!this.banner) this.init();
                if (!this.banner || this.visible) return;

                this.banner.style.display = 'block';
                this.visible = true;

                // Add CSS styles dynamically if not already present
                if (!document.getElementById('sse-banner-styles')) {
                    const style = document.createElement('style');
                    style.id = 'sse-banner-styles';
                    style.textContent = `
                        .sse-status-banner {
                            position: sticky;
                            top: 0;
                            z-index: 1000;
                            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
                            color: white;
                            padding: 12px 20px;
                            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                            animation: slideDown 0.3s ease-out;
                        }

                        @keyframes slideDown {
                            from {
                                transform: translateY(-100%);
                                opacity: 0;
                            }
                            to {
                                transform: translateY(0);
                                opacity: 1;
                            }
                        }

                        .sse-status-banner .banner-content {
                            display: flex;
                            align-items: center;
                            gap: 16px;
                            max-width: 1200px;
                            margin: 0 auto;
                        }

                        .sse-status-banner .banner-icon {
                            font-size: 24px;
                            flex-shrink: 0;
                        }

                        .sse-status-banner .banner-message {
                            flex: 1;
                            display: flex;
                            flex-direction: column;
                            gap: 4px;
                        }

                        .sse-status-banner .banner-message strong {
                            font-size: 16px;
                            font-weight: 600;
                        }

                        .sse-status-banner .banner-message span {
                            font-size: 14px;
                            opacity: 0.95;
                        }

                        .sse-status-banner .banner-action {
                            background: white;
                            color: #ee5a24;
                            border: none;
                            padding: 8px 20px;
                            border-radius: 4px;
                            font-weight: 600;
                            cursor: pointer;
                            transition: transform 0.2s, box-shadow 0.2s;
                            flex-shrink: 0;
                        }

                        .sse-status-banner .banner-action:hover {
                            transform: translateY(-1px);
                            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                        }

                        .sse-status-banner .banner-close {
                            background: transparent;
                            border: none;
                            color: white;
                            font-size: 28px;
                            line-height: 1;
                            cursor: pointer;
                            padding: 0;
                            width: 32px;
                            height: 32px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            border-radius: 4px;
                            transition: background 0.2s;
                            flex-shrink: 0;
                        }

                        .sse-status-banner .banner-close:hover {
                            background: rgba(255,255,255,0.2);
                        }

                        @media (max-width: 768px) {
                            .sse-status-banner .banner-content {
                                flex-wrap: wrap;
                                gap: 12px;
                            }

                            .sse-status-banner .banner-message {
                                flex-basis: 100%;
                                order: 1;
                            }

                            .sse-status-banner .banner-icon {
                                order: 0;
                            }

                            .sse-status-banner .banner-action {
                                order: 2;
                                flex: 1;
                            }

                            .sse-status-banner .banner-close {
                                order: 3;
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }

                console.log('[SSE Banner] Shown - connection lost');
            },

            hide() {
                if (!this.banner || !this.visible) return;

                this.banner.style.display = 'none';
                this.visible = false;
                console.log('[SSE Banner] Hidden');
            },

            isVisible() {
                return this.visible;
            }
        };

        // Make globally accessible
        window.SSEStatusBanner = SSEStatusBanner;

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            SSEStatusBanner.init();
        });
    </script>

    <!-- Analysis State Tracker for beforeunload protection -->
    <script>
        const AnalysisStateTracker = {
            activeAnalysis: false,

            setAnalysisRunning(isRunning) {
                this.activeAnalysis = isRunning;
                console.log('Analysis state changed:', isRunning ? 'running' : 'stopped');
            },

            isAnalysisRunning() {
                return this.activeAnalysis;
            }
        };

        // Prevent closing during active analysis
        window.addEventListener('beforeunload', function(e) {
            if (AnalysisStateTracker.isAnalysisRunning()) {
                // Modern browsers require returnValue to be set
                e.preventDefault();
                e.returnValue = '';

                // Note: Modern browsers don't show custom messages anymore for security reasons
                // They show their own generic message like "Leave site? Changes you made may not be saved"
                return '';
            }
        });

        // Make tracker globally accessible
        window.AnalysisStateTracker = AnalysisStateTracker;
    </script>

    
<script>
(function() {
    const addAccountBtn = document.getElementById('add-account-btn');
    const modal = document.getElementById('add-account-modal');
    const closeBtn = document.getElementById('close-add-account-modal');
    const tabs = document.querySelectorAll('.modal-tab');
    const tabContents = document.querySelectorAll('.tab-content');

    // Open modal
    addAccountBtn.addEventListener('click', function() {
        modal.classList.add('show');
        document.body.style.overflow = 'hidden';

        // Trigger HTMX to load auth form
        htmx.trigger(document.getElementById('auth-form-container'), 'modal-opened');

        // Focus first input in active tab
        setTimeout(() => {
            const activeTab = document.querySelector('.tab-content.active');
            if (!activeTab) return;
            const firstInput = activeTab.querySelector('input:not([type="hidden"]), select');
            if (firstInput) firstInput.focus();
        }, 100);
    });

    // Close modal
    function closeModal() {
        modal.classList.remove('show');
        document.body.style.overflow = '';
    }

    closeBtn.addEventListener('click', closeModal);

    // Close on overlay click
    modal.addEventListener('click', function(e) {
        if (e.target === modal) {
            closeModal();
        }
    });

    // Close on Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && modal.classList.contains('show')) {
            closeModal();
        }
    });

    // Tab switching
    tabs.forEach(tab => {
        tab.addEventListener('click', function() {
            const targetTab = this.dataset.tab;

            // Update tab buttons
            tabs.forEach(t => {
                t.classList.remove('active');
                t.setAttribute('aria-selected', 'false');
            });
            this.classList.add('active');
            this.setAttribute('aria-selected', 'true');

            // Update tab content
            tabContents.forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById('tab-' + targetTab).classList.add('active');

            // Focus first input in new tab
            const activeContent = document.getElementById('tab-' + targetTab);
            const firstInput = activeContent.querySelector('input:not([type="hidden"]), select');
            if (firstInput) firstInput.focus();
        });
    });

    // Close modal on successful session creation
    document.body.addEventListener('htmx:afterSwap', function(e) {
        const resultDiv = e.detail.target;

        // Check for success in auth result or upload result
        if ((resultDiv.id === 'auth-flow-result' || resultDiv.id === 'import-save-result') &&
            resultDiv.querySelector('.alert-success')) {
            // Close modal after short delay
            setTimeout(() => {
                closeModal();
                // Refresh sessions list
                htmx.trigger(document.getElementById('sessions-list'), 'refreshSessions');
            }, 1500);
        }
    });

    // Handle session deletion with modal confirmation
    document.body.addEventListener('click', async function(e) {
        const deleteBtn = e.target.closest('.session-delete-btn');
        if (!deleteBtn) return;

        e.preventDefault();
        const sessionId = deleteBtn.dataset.sessionId;
        const lockKey = deleteBtn.dataset.lock;

        // Check optimistic lock
        if (typeof OptimisticLock !== 'undefined' && !OptimisticLock.tryAcquireLock('session', sessionId, 'delete')) {
            const lockInfo = OptimisticLock.getLockInfo('session', sessionId, 'delete');
            const message = lockInfo
                ? `Deletion is already in progress in another tab (${Math.round((Date.now() - lockInfo.timestamp) / 1000)}s ago)`
                : 'Deletion is already in progress in another tab';

            ToastManager.warning(message, {
                title: 'Operation in Progress',
                duration: 5000
            });
            return;
        }

        // Show modal confirmation
        const confirmed = await ModalManager.confirm({
            type: 'danger',
            icon: 'üóëÔ∏è',
            title: 'Delete Telegram Account',
            message: `Are you sure you want to delete the account "${sessionId}"? This action cannot be undone. All session data and credentials will be permanently removed.`,
            confirmText: 'Delete Account',
            cancelText: 'Cancel',
            confirmClass: 'danger'
        });

        if (!confirmed) {
            if (typeof OptimisticLock !== 'undefined') {
                OptimisticLock.releaseLock('session', sessionId, 'delete');
            }
            return;
        }

        // Proceed with deletion
        try {
            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
            const response = await fetch(`/api/sessions/${sessionId}`, {
                method: 'DELETE',
                headers: { 'X-CSRF-Token': csrfToken }
            });

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            // Remove element from DOM
            const sessionElement = document.getElementById(`session-${sessionId}`);
            if (sessionElement) {
                sessionElement.classList.add('removing');
                setTimeout(() => sessionElement.remove(), 300);
            }

            ToastManager.success(`Account has been deleted.`, {
                title: 'Account Deleted',
                duration: 5000
            });

            if (typeof OptimisticLock !== 'undefined') {
                OptimisticLock.releaseLock('session', sessionId, 'delete');
            }

        } catch (error) {
            console.error('Failed to delete session:', error);

            if (typeof OptimisticLock !== 'undefined') {
                OptimisticLock.releaseLock('session', sessionId, 'delete');
            }

            ToastManager.error(`Failed to delete account: ${error.message}`, {
                title: 'Deletion Failed',
                duration: 8000,
                actions: [{
                    label: 'Retry',
                    class: 'retry',
                    action: 'retry',
                    callback: () => deleteBtn.click()
                }]
            });
        }
    });
})();
</script>

</body>
</html>
200