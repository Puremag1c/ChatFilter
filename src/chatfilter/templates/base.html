<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token }}">
    <title>{% block title %}ChatFilter{% endblock %}</title>
    <link rel="stylesheet" href="/static/css/style.css">
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="/static/js/tab-sync.js"></script>
    <script src="/static/js/tab-activity.js"></script>
    <script src="/static/js/request-dedup.js"></script>
    <script src="/static/js/optimistic-lock.js"></script>
    <script src="/static/js/conflict-warnings.js"></script>
    {% block head %}{% endblock %}
</head>
<body>
    <!-- Skip to main content link for keyboard navigation -->
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <header role="banner">
        <nav role="navigation" aria-label="Main navigation">
            <a href="/" class="logo">ChatFilter</a>
            <ul class="nav-links">
                <li><a href="/">Sessions</a></li>
                <li><a href="/chats">Chats</a></li>
                <li><a href="/chatlist">Import</a></li>
                <li><a href="/results">Results</a></li>
                <li><a href="/proxy">Proxy</a></li>
            </ul>
            <div class="status-indicators">
                <div class="network-status" id="network-status" role="status" aria-live="polite">
                    <span class="status-indicator" id="network-indicator" aria-hidden="true"></span>
                    <span class="status-text" id="network-text">Online</span>
                </div>
                <div class="telegram-status" id="telegram-status" role="status" aria-live="polite">
                    <span class="status-indicator" id="status-indicator" aria-hidden="true"></span>
                    <span class="status-text" id="status-text">Checking...</span>
                </div>
            </div>
        </nav>
    </header>
    <main id="main-content" role="main">
        {% block content %}{% endblock %}
    </main>
    <footer role="contentinfo">
        <p>ChatFilter v{{ version }}</p>
        <div class="footer-actions">
            <a href="/api/export/diagnostics?format=text"
               download
               class="diagnostic-button"
               aria-label="Export diagnostic information for troubleshooting">
                Export Diagnostics
            </a>
        </div>
    </footer>

    <!-- Toast notification container with ARIA live region -->
    <div id="toast-container" role="alert" aria-live="assertive" aria-atomic="true"></div>

    <!-- CSRF Token Configuration for HTMX -->
    <script>
        // Configure HTMX to include CSRF token in all POST/DELETE requests
        document.addEventListener('DOMContentLoaded', function() {
            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;

            if (csrfToken) {
                // Add CSRF token to all HTMX requests
                document.body.addEventListener('htmx:configRequest', function(event) {
                    // Only add token to POST/DELETE requests
                    if (event.detail.verb === 'post' || event.detail.verb === 'delete') {
                        event.detail.headers['X-CSRF-Token'] = csrfToken;
                    }
                });
            } else {
                console.warn('CSRF token not found in page meta tags');
            }
        });
    </script>

    <!-- Global error handling and toast system -->
    <script>
        // Toast Notification System
        const ToastManager = {
            container: null,
            queue: [],
            maxToasts: 3,
            defaultDuration: 5000,

            init() {
                this.container = document.getElementById('toast-container');
                if (!this.container) {
                    this.container = document.createElement('div');
                    this.container.id = 'toast-container';
                    document.body.appendChild(this.container);
                }
            },

            show(options) {
                if (!this.container) this.init();

                const toast = {
                    id: Date.now() + Math.random(),
                    type: options.type || 'info',
                    title: options.title || this.getDefaultTitle(options.type),
                    message: options.message || '',
                    duration: options.duration !== undefined ? options.duration : this.defaultDuration,
                    actions: options.actions || [],
                    onClose: options.onClose
                };

                this.queue.push(toast);
                this.render();

                if (toast.duration > 0) {
                    setTimeout(() => this.hide(toast.id), toast.duration);
                }

                return toast.id;
            },

            hide(toastId) {
                const toast = this.queue.find(t => t.id === toastId);
                if (!toast) return;

                const element = document.querySelector(`[data-toast-id="${toastId}"]`);
                if (element) {
                    element.classList.add('hiding');
                    setTimeout(() => {
                        this.queue = this.queue.filter(t => t.id !== toastId);
                        this.render();
                        if (toast.onClose) toast.onClose();
                    }, 300);
                }
            },

            hideAll() {
                const toastIds = this.queue.map(t => t.id);
                toastIds.forEach(id => this.hide(id));
            },

            render() {
                const visibleToasts = this.queue.slice(-this.maxToasts);
                this.container.innerHTML = visibleToasts.map(toast => this.createToastHTML(toast)).join('');

                setTimeout(() => {
                    visibleToasts.forEach(toast => {
                        const element = document.querySelector(`[data-toast-id="${toast.id}"]`);
                        if (element) element.classList.add('show');
                    });
                }, 10);
            },

            createToastHTML(toast) {
                const icons = {
                    error: '✕',
                    success: '✓',
                    warning: '⚠',
                    info: 'ℹ'
                };

                const iconLabels = {
                    error: 'Error',
                    success: 'Success',
                    warning: 'Warning',
                    info: 'Information'
                };

                const actionsHTML = toast.actions.length > 0 ? `
                    <div class="toast-actions">
                        ${toast.actions.map(action => `
                            <button class="toast-action ${action.class || ''}"
                                    onclick="ToastManager.handleAction('${toast.id}', '${action.action}')"
                                    aria-label="${this.escapeHtml(action.label)}">
                                ${action.label}
                            </button>
                        `).join('')}
                    </div>
                ` : '';

                return `
                    <div class="toast toast-${toast.type}" data-toast-id="${toast.id}" role="alert" aria-live="assertive">
                        <div class="toast-icon" aria-label="${iconLabels[toast.type] || iconLabels.info}" role="img">${icons[toast.type] || icons.info}</div>
                        <div class="toast-content">
                            <div class="toast-title">${this.escapeHtml(toast.title)}</div>
                            ${toast.message ? `<div class="toast-message">${this.escapeHtml(toast.message)}</div>` : ''}
                            ${actionsHTML}
                        </div>
                        <button class="toast-close" onclick="ToastManager.hide('${toast.id}')" aria-label="Close notification">&times;</button>
                    </div>
                `;
            },

            handleAction(toastId, action) {
                const toast = this.queue.find(t => t.id === toastId);
                if (!toast) return;

                const actionObj = toast.actions.find(a => a.action === action);
                if (actionObj && actionObj.callback) {
                    actionObj.callback();
                }

                this.hide(toastId);
            },

            getDefaultTitle(type) {
                const titles = {
                    error: 'Error',
                    success: 'Success',
                    warning: 'Warning',
                    info: 'Info'
                };
                return titles[type] || 'Notification';
            },

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            // Convenience methods
            error(message, options = {}) {
                return this.show({ ...options, type: 'error', message });
            },

            success(message, options = {}) {
                return this.show({ ...options, type: 'success', message });
            },

            warning(message, options = {}) {
                return this.show({ ...options, type: 'warning', message });
            },

            info(message, options = {}) {
                return this.show({ ...options, type: 'info', message });
            }
        };

        // Initialize toast system
        ToastManager.init();

        // Global error boundary
        window.addEventListener('error', function(event) {
            console.error('Global error caught:', event.error);

            ToastManager.error(
                event.error?.message || 'An unexpected error occurred',
                {
                    title: 'Application Error',
                    duration: 0,
                    actions: [{
                        label: 'Reload Page',
                        class: 'retry',
                        action: 'reload',
                        callback: () => window.location.reload()
                    }, {
                        label: 'Dismiss',
                        class: 'dismiss',
                        action: 'dismiss'
                    }]
                }
            );
        });

        // Global unhandled promise rejection handler
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);

            ToastManager.error(
                event.reason?.message || 'An unexpected error occurred',
                {
                    title: 'Application Error',
                    duration: 8000
                }
            );
        });

        // Make ToastManager globally accessible
        window.ToastManager = ToastManager;

        // HTMX Error Handling Configuration
        document.body.addEventListener('htmx:responseError', function(event) {
            const status = event.detail.xhr.status;
            const statusText = event.detail.xhr.statusText;
            let message = 'An error occurred while processing your request';
            let title = 'Request Failed';

            // Parse error response if JSON
            try {
                const response = JSON.parse(event.detail.xhr.responseText);
                if (response.detail) {
                    message = response.detail;
                }
            } catch (e) {
                // If not JSON, use status text
                if (status === 404) {
                    message = 'The requested resource was not found';
                    title = 'Not Found';
                } else if (status === 403) {
                    message = 'You do not have permission to access this resource';
                    title = 'Access Denied';
                } else if (status === 422) {
                    message = 'Invalid input. Please check your data and try again';
                    title = 'Validation Error';
                } else if (status >= 500) {
                    message = 'A server error occurred. Please try again later';
                    title = 'Server Error';
                } else if (statusText) {
                    message = statusText;
                }
            }

            // Get the retry action if available
            const target = event.detail.target;
            const canRetry = target && (target.tagName === 'FORM' || target.hasAttribute('hx-get') || target.hasAttribute('hx-post'));

            const actions = [];
            if (canRetry) {
                actions.push({
                    label: 'Retry',
                    class: 'retry',
                    action: 'retry',
                    callback: () => {
                        htmx.trigger(target, target.tagName === 'FORM' ? 'submit' : 'click');
                    }
                });
            }
            actions.push({
                label: 'Dismiss',
                class: 'dismiss',
                action: 'dismiss'
            });

            ToastManager.error(message, {
                title: title,
                duration: 8000,
                actions: actions
            });
        });

        // HTMX network error (timeout, connection failed, etc.)
        document.body.addEventListener('htmx:sendError', function(event) {
            const target = event.detail.target;
            const canRetry = target && (target.tagName === 'FORM' || target.hasAttribute('hx-get') || target.hasAttribute('hx-post'));

            const actions = [];
            if (canRetry) {
                actions.push({
                    label: 'Retry',
                    class: 'retry',
                    action: 'retry',
                    callback: () => {
                        htmx.trigger(target, target.tagName === 'FORM' ? 'submit' : 'click');
                    }
                });
            }
            actions.push({
                label: 'Dismiss',
                class: 'dismiss',
                action: 'dismiss'
            });

            ToastManager.error(
                'Unable to connect to the server. Please check your internet connection',
                {
                    title: 'Connection Error',
                    duration: 8000,
                    actions: actions
                }
            );
        });

        // HTMX timeout error
        document.body.addEventListener('htmx:timeout', function(event) {
            const target = event.detail.target;
            const canRetry = target && (target.tagName === 'FORM' || target.hasAttribute('hx-get') || target.hasAttribute('hx-post'));

            const actions = [];
            if (canRetry) {
                actions.push({
                    label: 'Retry',
                    class: 'retry',
                    action: 'retry',
                    callback: () => {
                        htmx.trigger(target, target.tagName === 'FORM' ? 'submit' : 'click');
                    }
                });
            }
            actions.push({
                label: 'Dismiss',
                class: 'dismiss',
                action: 'dismiss'
            });

            ToastManager.error(
                'The request took too long to complete. The server may be busy',
                {
                    title: 'Request Timeout',
                    duration: 8000,
                    actions: actions
                }
            );
        });

        // HTMX swap error (invalid response format)
        document.body.addEventListener('htmx:swapError', function(event) {
            console.error('HTMX swap error:', event.detail);

            ToastManager.error(
                'The server returned an unexpected response format',
                {
                    title: 'Response Error',
                    duration: 8000
                }
            );
        });

        // Log successful responses (optional, for debugging)
        // document.body.addEventListener('htmx:afterSwap', function(event) {
        //     console.log('HTMX swap successful:', event.detail);
        // });
    </script>

    <!-- Telegram Connection Status Monitor -->
    <script>
        const TelegramStatusMonitor = {
            pollInterval: 5000, // Poll every 5 seconds
            timeoutId: null,
            lastStatus: null,
            consecutiveErrors: 0,
            maxErrors: 3,

            async checkStatus() {
                try {
                    const response = await fetch('/api/telegram/status');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    this.consecutiveErrors = 0;
                    this.updateUI(data);
                    this.notifyStatusChange(data);

                } catch (error) {
                    console.error('Failed to fetch Telegram status:', error);
                    this.consecutiveErrors++;

                    // Show error state in UI
                    this.updateUI({
                        connected: false,
                        sessions_count: 0,
                        error: this.consecutiveErrors >= this.maxErrors
                            ? 'Connection monitor offline'
                            : 'Checking...'
                    });

                    // Show toast notification after multiple failures
                    if (this.consecutiveErrors === this.maxErrors) {
                        ToastManager.warning(
                            'Unable to check Telegram connection status',
                            {
                                title: 'Status Monitor',
                                duration: 5000
                            }
                        );
                    }
                }

                // Schedule next poll
                this.timeoutId = setTimeout(() => this.checkStatus(), this.pollInterval);
            },

            updateUI(status) {
                const indicator = document.getElementById('status-indicator');
                const text = document.getElementById('status-text');
                const container = document.getElementById('telegram-status');

                if (!indicator || !text || !container) return;

                // Remove all status classes
                container.classList.remove('status-connected', 'status-disconnected', 'status-error');

                if (status.error) {
                    // Error state
                    container.classList.add('status-error');
                    text.textContent = 'Error';
                    container.title = `Telegram Status: Error - ${status.error}`;
                } else if (status.connected) {
                    // Connected state
                    container.classList.add('status-connected');
                    const sessionsText = status.sessions_count === 1
                        ? '1 session'
                        : `${status.sessions_count} sessions`;
                    text.textContent = `Connected (${sessionsText})`;
                    container.title = `Telegram Status: Connected with ${sessionsText}`;
                } else {
                    // Disconnected state
                    container.classList.add('status-disconnected');
                    text.textContent = 'Disconnected';
                    container.title = 'Telegram Status: No active sessions';
                }
            },

            notifyStatusChange(newStatus) {
                // Only notify on actual state changes
                if (!this.lastStatus) {
                    this.lastStatus = newStatus;
                    return;
                }

                const wasConnected = this.lastStatus.connected;
                const isConnected = newStatus.connected;

                if (wasConnected !== isConnected) {
                    if (isConnected) {
                        ToastManager.success(
                            `Connected with ${newStatus.sessions_count} session${newStatus.sessions_count !== 1 ? 's' : ''}`,
                            {
                                title: 'Telegram Connected',
                                duration: 3000
                            }
                        );

                        // Broadcast to other tabs
                        if (typeof TabSync !== 'undefined') {
                            TabSync.broadcast('telegram-status', { connected: true });
                        }
                    } else {
                        ToastManager.warning(
                            'No active Telegram sessions',
                            {
                                title: 'Telegram Disconnected',
                                duration: 5000
                            }
                        );

                        // Broadcast to other tabs
                        if (typeof TabSync !== 'undefined') {
                            TabSync.broadcast('telegram-status', { connected: false });
                        }
                    }
                }

                this.lastStatus = newStatus;
            },

            start() {
                console.log('Starting Telegram status monitor');
                this.checkStatus();

                // Listen for status updates from other tabs
                if (typeof TabSync !== 'undefined') {
                    TabSync.on('telegram-status', (data) => {
                        console.log('Received status update from another tab:', data);
                        // Immediately check status to sync with other tabs
                        this.checkStatus();
                    });
                }
            },

            stop() {
                console.log('Stopping Telegram status monitor');
                if (this.timeoutId) {
                    clearTimeout(this.timeoutId);
                    this.timeoutId = null;
                }
            }
        };

        // Start monitoring when page loads
        document.addEventListener('DOMContentLoaded', function() {
            TelegramStatusMonitor.start();
        });

        // Stop monitoring when page unloads
        window.addEventListener('beforeunload', function() {
            TelegramStatusMonitor.stop();
        });

        // Handle page visibility changes (pause when hidden to save resources)
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                TelegramStatusMonitor.stop();
            } else {
                TelegramStatusMonitor.start();
            }
        });

        // Make monitor globally accessible for debugging
        window.TelegramStatusMonitor = TelegramStatusMonitor;
    </script>

    {% block scripts %}{% endblock %}
</body>
</html>
