{% extends "base.html" %}

{% block title %}{{ _("Chat Groups") }} - ChatFilter{% endblock %}

{% block head %}
<style>
    .groups-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        flex-wrap: wrap;
        gap: 1rem;
    }

    .groups-list {
        display: grid;
        gap: 1.5rem;
        grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
    }

    .group-card {
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 1.5rem;
        background: var(--bg-card);
        transition: box-shadow 0.2s;
    }

    .group-card:hover {
        box-shadow: 0 4px 12px var(--shadow-md);
    }

    /* Pulse animation for in_progress cards (lightweight: opacity + border-color) */
    @keyframes pulse {
        0%, 100% {
            opacity: 1;
            border-color: rgba(21, 101, 192, 0.6);
        }
        50% {
            opacity: 0.85;
            border-color: rgba(21, 101, 192, 0.9);
        }
    }

    .group-card.in_progress {
        animation: pulse 2s ease-in-out infinite;
    }

    .group-card h3 {
        margin: 0 0 1rem 0;
        font-size: 1.25rem;
    }

    .group-stats {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        margin-bottom: 1rem;
    }

    .stat-row {
        display: flex;
        justify-content: space-between;
        font-size: 0.875rem;
    }

    .progress-bar {
        height: 8px;
        background: var(--bg-skeleton);
        border-radius: 4px;
        overflow: hidden;
        margin: 0.5rem 0;
    }

    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #4caf50, #81c784);
        transition: width 0.3s ease;
    }

    .type-breakdown {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        margin: 0.75rem 0;
    }

    .type-badge {
        padding: 0.25rem 0.5rem;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 500;
    }

    .type-badge.group { background-color: #e8f5e9; color: #2e7d32; }
    .type-badge.forum { background-color: #fce4ec; color: #c2185b; }
    .type-badge.channel-comments { background-color: #e3f2fd; color: #1565c0; }
    .type-badge.channel-no-comments { background-color: #f3e5f5; color: #7b1fa2; }
    .type-badge.dead { background-color: #ffebee; color: #c62828; }
    .type-badge.pending { background-color: #fff3e0; color: #ef6c00; }
    .type-badge.done { background-color: #e8f5e9; color: #2e7d32; }
    .type-badge.error { background-color: #ffebee; color: #c62828; }

    .group-actions {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        margin-top: 1rem;
    }

    .group-actions .btn {
        flex: 1;
        min-width: 100px;
        font-size: 0.875rem;
        padding: 0.5rem 0.75rem;
    }

    .status-badge {
        display: inline-block;
        padding: 0.25rem 0.75rem;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 500;
        text-transform: uppercase;
        margin-bottom: 0.5rem;
    }

    .status-badge.pending { background-color: #fff3e0; color: #ef6c00; }
    .status-badge.in_progress { background-color: #e3f2fd; color: #1565c0; }
    .status-badge.paused { background-color: #fff9c4; color: #f57f17; }
    .status-badge.waiting_for_accounts { background-color: #fff3e0; color: #e65100; }
    .status-badge.completed { background-color: #e8f5e9; color: #2e7d32; }

    .no-groups {
        padding: 3rem;
        text-align: center;
        color: var(--text-secondary);
        border: 2px dashed var(--border-color);
        border-radius: 8px;
    }

    .no-groups p {
        margin: 0.5rem 0;
    }

    .current-chat-title {
        font-style: italic;
        color: var(--text-secondary);
        max-width: 200px;
        display: inline-block;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        vertical-align: bottom;
    }

    @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    @media (max-width: 768px) {
        .groups-list {
            grid-template-columns: 1fr;
        }

        .group-actions {
            flex-direction: column;
        }

        .group-actions .btn {
            width: 100%;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="page-header">
    <h1>{{ _("Chat Groups") }}</h1>
    <p class="subtitle">{{ _("Manage and analyze groups of chats") }}</p>
</div>

<section class="card">
    <div class="groups-header">
        <h2>{{ _("Groups") }}</h2>
        <button class="btn btn-primary"
                hx-get="/api/groups/modal/create"
                hx-target="#modal-container"
                hx-swap="innerHTML">
            {{ _("Import chats") }}
        </button>
    </div>

    <div id="groups-container"
         role="region"
         aria-live="polite"
         aria-label="{{ _("Groups list") }}"
         hx-ext="sse"
         sse-connect="/api/groups/events">
        <div class="groups-list" id="groups-list">
            <div class="no-groups" role="status">
                <p>{{ _("Loading groups...") }}</p>
            </div>
        </div>
    </div>
</section>
{% endblock %}

{% block scripts %}
<script src="/static/js/morphdom.min.js"></script>
<script src="/static/js/groups.js"></script>
<script>
// Handle SSE connection errors - show persistent banner when connection drops
document.body.addEventListener('htmx:sseError', function(evt) {
    console.error('[SSE] Connection error:', evt.detail);

    // Show persistent banner to inform user that realtime updates stopped
    if (typeof SSEStatusBanner !== 'undefined') {
        SSEStatusBanner.show();
    }

    // Also show a brief toast for immediate feedback
    if (typeof ToastManager !== 'undefined') {
        ToastManager.warning('{{ _("Connection lost. Real-time updates paused.") }}', {
            duration: 4000
        });
    }
});

// Vanilla JS polling replaces HTMX polling to prevent duplicate card accumulation.
// HTMX innerHTML swap + settle processing + request-dedup interactions caused
// exponential card duplication. Plain fetch + innerHTML avoids all HTMX swap machinery.
(function() {
    var container = document.getElementById('groups-container');
    var pollTimer = null;
    var isRefreshing = false;

    // Execute <script> tags inserted via innerHTML (browser spec: innerHTML does NOT run scripts).
    // Creates new script elements and appends them so the browser evaluates the code.
    function executeScripts(el) {
        var scripts = el.querySelectorAll('script');
        scripts.forEach(function(oldScript) {
            var newScript = document.createElement('script');
            // Copy attributes (e.g. type, src)
            Array.from(oldScript.attributes).forEach(function(attr) {
                newScript.setAttribute(attr.name, attr.value);
            });
            newScript.textContent = oldScript.textContent;
            oldScript.parentNode.replaceChild(newScript, oldScript);
        });
    }

    function refreshGroups() {
        if (isRefreshing) return;
        isRefreshing = true;

        // BEFORE swap: collect group IDs that are currently active (in_progress or waiting_for_accounts)
        var currentInProgress = new Set();
        container.querySelectorAll('.group-card').forEach(function(card) {
            var statusBadge = card.querySelector('.status-badge.in_progress') || card.querySelector('.status-badge.waiting_for_accounts');
            if (statusBadge && card.id) {
                // card.id format: "group-{group_id}"
                currentInProgress.add(card.id);
            }
        });

        fetch('/api/groups')
            .then(function(resp) { return resp.text(); })
            .then(function(html) {
                // Use morphdom to smoothly update DOM instead of innerHTML swap
                // Wrap html in temporary container to preserve #groups-container structure
                var tempDiv = document.createElement('div');
                tempDiv.innerHTML = html;

                morphdom(container, tempDiv.firstChild, {
                    childrenOnly: true,  // Only morph children, preserve container
                    onBeforeElUpdated: function(fromEl, toEl) {
                        // Preserve htmx attributes and event listeners on unchanged elements
                        return true;
                    }
                });

                htmx.process(container);
                executeScripts(container);

                // AFTER swap: check which groups transitioned from in_progress to completed/paused
                container.querySelectorAll('.group-card').forEach(function(card) {
                    var completedBadge = card.querySelector('.status-badge.completed');
                    var pausedBadge = card.querySelector('.status-badge.paused');

                    // If this group was in_progress and is now completed/paused → show toast
                    if ((completedBadge || pausedBadge) && card.id && currentInProgress.has(card.id)) {
                        ToastManager.success('Анализ завершён');
                    }
                });

                schedulePoll();
            })
            .catch(function() { schedulePoll(); })
            .finally(function() { isRefreshing = false; });
    }

    function schedulePoll() {
        if (pollTimer) clearTimeout(pollTimer);
        // SSE-aware polling with safety net
        // SSE handles real-time updates for in_progress groups
        // Polling is fallback for both SSE (slow) and non-SSE (fast) states
        var hasActive = container.querySelector('.status-badge.in_progress') || container.querySelector('.status-badge.waiting_for_accounts');
        if (hasActive) {
            // Slow polling when SSE active - safety net in case listener is broken
            // 30s interval allows eventual consistency even if SSE fails
            pollTimer = setTimeout(refreshGroups, 30000);
        } else {
            // Fast polling when no SSE connections - check for new groups
            pollTimer = setTimeout(refreshGroups, 3000);
        }
    }

    // Listen for HX-Trigger refreshGroups events from button actions
    document.body.addEventListener('refreshGroups', function() {
        refreshGroups();
    });

    // Add loading state for Resume button (paused → in_progress transition)
    // htmx:beforeRequest fires when Resume button is clicked
    document.body.addEventListener('htmx:beforeRequest', function(event) {
        var target = event.detail.elt;

        // Check if this is a resume action
        if (target && target.tagName === 'BUTTON' &&
            event.detail.requestConfig &&
            event.detail.requestConfig.path &&
            event.detail.requestConfig.path.match(/\/api\/groups\/[^\/]+\/resume$/)) {

            // Find parent card
            var card = target.closest('.group-card');
            if (!card) return;

            // Save original button text
            target.setAttribute('data-original-text', target.textContent);

            // Show loading state
            target.innerHTML = '<span style="display: inline-flex; align-items: center; gap: 0.5rem;">' +
                '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="animation: spin 1s linear infinite;">' +
                '<circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" stroke-opacity="0.25"/>' +
                '<path d="M12 2 A10 10 0 0 1 22 12" stroke="currentColor" stroke-width="4" stroke-linecap="round"/>' +
                '</svg>' +
                '<span>Resuming...</span>' +
                '</span>';
        }
    });

    // Clear loading state after card swap (refreshGroups triggers outerHTML swap)
    document.body.addEventListener('htmx:afterSwap', function(event) {
        // Check if swap was on a group card (hx-target="#group-{id}")
        if (event.detail.target && event.detail.target.id &&
            event.detail.target.id.match(/^group-/)) {
            // Card was swapped — loading state is gone (new card rendered)
            // Nothing to do here, but keeping for clarity
        }
    });

    // Show toast when analysis starts (start/reanalyze endpoints)
    document.body.addEventListener('htmx:afterRequest', function(event) {
        var xhr = event.detail.xhr;
        var requestConfig = event.detail.requestConfig;

        // Check if this was a successful start or reanalyze request
        // Match paths: /api/groups/{group_id}/start or /api/groups/{group_id}/reanalyze (with optional query params)
        if (xhr.status === 204 && requestConfig && requestConfig.path &&
            requestConfig.path.match(/\/api\/groups\/[^\/]+\/(start|reanalyze)(\?|$)/)) {
            ToastManager.info('Анализ запущен');
        }
    });

    // Initial load
    refreshGroups();
})();
</script>
{% endblock %}
