<div class="group-card {{ group.status.value }}" id="group-{{ group.id }}" data-last-sse-event="0">
    <!-- SSE event handlers: hidden elements for HTMX SSE extension to register EventSource listeners -->
    <div sse-swap="init" style="display:none"></div>
    <div sse-swap="progress" style="display:none"></div>
    <div sse-swap="complete" style="display:none"></div>
    <div sse-swap="error" style="display:none"></div>
    <div sse-swap="ping" style="display:none"></div>

    <h3>{{ group.name }}</h3>

    <span class="status-badge {{ group.status.value }}">{{ _(group.status.value) }}</span>
    {% if group.status.value in ('in_progress', 'waiting_for_accounts') %}
    <div id="error-warning-{{ group.id }}" class="error-warning" style="display: none; background: #ffebee; color: #c62828; padding: 0.5rem; border-radius: 4px; margin: 0.5rem 0; font-size: 0.875rem;">
        <strong>{{ _("Analysis error") }}:</strong> <span id="error-message-{{ group.id }}"></span>
    </div>
    <div id="stale-warning-{{ group.id }}" class="stale-warning" style="display: none; background: #fff9c4; color: #f57f17; padding: 0.5rem; border-radius: 4px; margin: 0.5rem 0; font-size: 0.875rem;">
        Нет обновлений более 60 секунд. Возможно, анализ завис.
    </div>
    <div id="flood-wait-{{ group.id }}" class="flood-wait-info" style="display: none; background: #fff3e0; color: #e65100; padding: 0.5rem; border-radius: 4px; margin: 0.5rem 0; font-size: 0.875rem;">
        FloodWait до <span id="flood-wait-time-{{ group.id }}">--:--</span>
        (<span id="flood-wait-countdown-{{ group.id }}">—</span>)
    </div>
    {% endif %}

    <div class="group-stats">
        <div class="stat-row">
            <span>{{ _("Total chats") }}:</span>
            <strong id="total-{{ group.id }}">{{ stats.total }}</strong>
        </div>
        <div class="stat-row">
            <span>{{ _("Processed") }}:</span>
            <strong id="processed-{{ group.id }}">{{ stats.analyzed }} / {{ stats.total }}</strong>
        </div>
        <div class="stat-row">
            <span>{{ _("Error") }}:</span>
            <strong id="error-{{ group.id }}">{{ stats.failed }}</strong>
        </div>
        {% if group.status.value in ('in_progress', 'waiting_for_accounts') %}
        <div class="stat-row">
            <span>{{ _("Current chat") }}:</span>
            <strong id="current-chat-{{ group.id }}" class="current-chat-title">—</strong>
        </div>
        <div class="stat-row">
            <span>{{ _("Elapsed time") }}:</span>
            <strong id="elapsed-{{ group.id }}">0:00</strong>
        </div>
        {% endif %}
    </div>

    <!-- Progress bar -->
    <div class="progress-bar">
        {% set progress_pct = (stats.analyzed / stats.total * 100) if stats.total > 0 else 0 %}
        <div class="progress-fill" id="progress-fill-{{ group.id }}" style="width: {{ progress_pct }}%"></div>
    </div>

    <!-- Type breakdown -->
    <div class="type-breakdown" id="type-breakdown-{{ group.id }}">
        <span class="type-badge pending" data-badge-type="pending" id="badge-pending-{{ group.id }}" style="display: {% if stats.pending > 0 %}inline{% else %}none{% endif %}">{{ _("Pending") }}: <span data-badge-count>{{ stats.pending }}</span></span>
        <span class="type-badge done" data-badge-type="done" id="badge-done-{{ group.id }}" style="display: {% if stats.analyzed - stats.failed > 0 %}inline{% else %}none{% endif %}">{{ _("Done") }}: <span data-badge-count>{{ stats.analyzed - stats.failed }}</span></span>
        <span class="type-badge error" data-badge-type="error" id="badge-error-{{ group.id }}" style="display: {% if stats.failed > 0 %}inline{% else %}none{% endif %}">{{ _("Error") }}: <span data-badge-count>{{ stats.failed }}</span></span>
        <span class="type-badge dead" data-badge-type="dead" id="badge-dead-{{ group.id }}" style="display: {% if stats.dead > 0 %}inline{% else %}none{% endif %}">{{ _("Dead") }}: <span data-badge-count>{{ stats.dead }}</span></span>
        {% if stats.groups > 0 %}
        <span class="type-badge group">{{ _("Groups") }}: {{ stats.groups }}</span>
        {% endif %}
        {% if stats.forums > 0 %}
        <span class="type-badge forum">{{ _("Forums") }}: {{ stats.forums }}</span>
        {% endif %}
        {% if stats.channels_with_comments > 0 %}
        <span class="type-badge channel-comments">{{ _("Channels+") }}: {{ stats.channels_with_comments }}</span>
        {% endif %}
        {% if stats.channels_no_comments > 0 %}
        <span class="type-badge channel-no-comments">{{ _("Channels") }}: {{ stats.channels_no_comments }}</span>
        {% endif %}
        {% if stats.skipped_moderation > 0 %}
        <span class="type-badge dead" title="{{ _('These chats require approval to join. Metrics requiring join are N/A') }}">{{ _("Skipped (moderation)") }}: {{ stats.skipped_moderation }}</span>
        {% endif %}
    </div>

    <!-- Action buttons -->
    <div class="group-actions">
        <button class="btn btn-secondary btn-sm"
                hx-get="/api/groups/modal/settings/{{ group.id }}"
                hx-target="#modal-container"
                hx-swap="innerHTML">
            {{ _("Configure analysis") }}
        </button>

        {% if group.status.value == 'in_progress' %}
        <button class="btn btn-warning btn-sm"
                hx-post="/api/groups/{{ group.id }}/stop"
                hx-swap="none">
            {{ _("Stop analysis") }}
        </button>
        {% elif group.status.value == 'waiting_for_accounts' %}
        <button class="btn btn-warning btn-sm"
                hx-post="/api/groups/{{ group.id }}/stop"
                hx-swap="none"
                hx-confirm="{{ _('Stop analysis? The group is waiting for account unblock (FloodWait). If you stop, you will need to resume manually.') }}">
            {{ _("Stop analysis") }}
        </button>
        {% elif group.status.value == 'paused' %}
        <button class="btn btn-primary btn-sm"
                hx-post="/api/groups/{{ group.id }}/resume"
                hx-target="#group-{{ group.id }}"
                hx-swap="outerHTML"
                hx-disabled-elt="this">
            {{ _("Продолжить анализ") }}
        </button>
        {% elif group.status.value == 'completed' %}
        <button class="btn btn-outline-secondary btn-sm"
                hx-post="/api/groups/{{ group.id }}/reanalyze?mode=increment"
                hx-swap="none"
                hx-disabled-elt="this">
            {{ _("Дополнить анализ") }}
        </button>
        <button class="btn btn-warning btn-sm"
                hx-get="/api/groups/modal/reanalyze-confirm/{{ group.id }}"
                hx-target="#modal-container"
                hx-swap="innerHTML">
            {{ _("Перезапустить анализ") }}
        </button>
        {% else %}
        <button class="btn btn-primary btn-sm"
                hx-post="/api/groups/{{ group.id }}/start"
                hx-swap="none"
                hx-disabled-elt="this">
            {{ _("Start analysis") }}
        </button>
        {% endif %}

        {% if stats.analyzed > 0 %}
        <button class="btn btn-success btn-sm"
                hx-get="/api/groups/{{ group.id }}/export/modal"
                hx-target="#modal-container"
                hx-swap="innerHTML">
            {{ _("Download results") }}
        </button>
        {% endif %}

        <button class="btn btn-danger btn-sm"
                hx-delete="/api/groups/{{ group.id }}"
                hx-swap="none"
                hx-confirm="{{ _('Delete group? This cannot be undone.') }}">
            {{ _("Delete") }}
        </button>
    </div>

    {% if error_message %}
    <script>
        ToastManager.error('{{ error_message | replace("'", "\\'") }}', {
            title: 'Cannot Start Analysis',
            duration: 8000
        });
    </script>
    {% endif %}
</div>

{% if group.status.value in ('in_progress', 'waiting_for_accounts') %}
<script>
(function() {
    const groupId = '{{ group.id }}';

    // AbortController for cleanup - abort() removes ALL listeners with this signal
    const abortController = new AbortController();
    const signal = abortController.signal;

    // DO NOT cache DOM references - look them up fresh on each event
    // This prevents stale references when refreshGroups() swaps innerHTML
    function getElements() {
        return {
            processedEl: document.getElementById('processed-' + groupId),
            errorEl: document.getElementById('error-' + groupId),
            currentChatEl: document.getElementById('current-chat-' + groupId),
            elapsedEl: document.getElementById('elapsed-' + groupId),
            progressFillEl: document.getElementById('progress-fill-' + groupId),
            errorWarningEl: document.getElementById('error-warning-' + groupId),
            errorMessageEl: document.getElementById('error-message-' + groupId),
            staleWarningEl: document.getElementById('stale-warning-' + groupId),
            floodWaitEl: document.getElementById('flood-wait-' + groupId),
            floodWaitTimeEl: document.getElementById('flood-wait-time-' + groupId),
            floodWaitCountdownEl: document.getElementById('flood-wait-countdown-' + groupId),
            statusBadgeEl: document.querySelector('#group-' + groupId + ' .status-badge'),
            cardEl: document.getElementById('group-' + groupId)
        };
    }

    let startTime = Date.now(); // Will be updated from init event
    let elapsedTimer = null;
    let staleCheckTimer = null;
    let floodWaitTimer = null;
    let floodWaitTarget = null; // Date object for flood_wait_until
    let lastEventTime = Date.now();
    const STALE_THRESHOLD_MS = 60 * 1000; // 60 seconds

    // Format elapsed time as M:SS
    function formatElapsed(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return mins + ':' + (secs < 10 ? '0' : '') + secs;
    }

    // Format time as HH:MM
    function formatTime(date) {
        const h = date.getHours();
        const m = date.getMinutes();
        return (h < 10 ? '0' : '') + h + ':' + (m < 10 ? '0' : '') + m;
    }

    // Update elapsed time every second
    function startElapsedTimer() {
        if (elapsedTimer) return; // Already running
        elapsedTimer = setInterval(function() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const els = getElements();
            if (els.elapsedEl) {
                els.elapsedEl.textContent = formatElapsed(elapsed);
            }
        }, 1000);
    }

    function stopElapsedTimer() {
        if (elapsedTimer) {
            clearInterval(elapsedTimer);
            elapsedTimer = null;
        }
    }

    // FloodWait countdown timer
    function startFloodWaitCountdown(untilDate) {
        floodWaitTarget = untilDate;
        stopFloodWaitCountdown();

        const els = getElements();
        if (els.floodWaitTimeEl) {
            els.floodWaitTimeEl.textContent = formatTime(untilDate);
        }
        if (els.floodWaitEl) {
            els.floodWaitEl.style.display = 'block';
        }

        floodWaitTimer = setInterval(function() {
            const remaining = Math.max(0, Math.floor((floodWaitTarget.getTime() - Date.now()) / 1000));
            const els = getElements();
            if (els.floodWaitCountdownEl) {
                if (remaining > 0) {
                    els.floodWaitCountdownEl.textContent = formatElapsed(remaining);
                } else {
                    els.floodWaitCountdownEl.textContent = 'скоро...';
                    stopFloodWaitCountdown();
                }
            }
        }, 1000);
    }

    function stopFloodWaitCountdown() {
        if (floodWaitTimer) {
            clearInterval(floodWaitTimer);
            floodWaitTimer = null;
        }
    }

    function hideFloodWait() {
        stopFloodWaitCountdown();
        floodWaitTarget = null;
        const els = getElements();
        if (els.floodWaitEl) {
            els.floodWaitEl.style.display = 'none';
        }
    }

    // Update status badge dynamically
    function updateStatusBadge(status) {
        const els = getElements();
        if (!els.statusBadgeEl) return;
        // Remove old status classes
        els.statusBadgeEl.className = 'status-badge ' + status;
        if (status === 'waiting_for_accounts') {
            els.statusBadgeEl.textContent = 'Ожидание аккаунтов';
        } else if (status === 'in_progress') {
            els.statusBadgeEl.textContent = 'In progress';
        }
    }

    // Check for stale SSE connection (no events for >60s)
    function checkStaleConnection() {
        const timeSinceLastEvent = Date.now() - lastEventTime;
        if (timeSinceLastEvent > STALE_THRESHOLD_MS) {
            // Show stale warning
            const els = getElements();
            if (els.staleWarningEl) {
                els.staleWarningEl.style.display = 'block';
            }
        }
    }

    // Start stale check timer (runs every 5s)
    function startStaleCheckTimer() {
        if (staleCheckTimer) return; // Already running
        staleCheckTimer = setInterval(checkStaleConnection, 5000);
    }

    function stopStaleCheckTimer() {
        if (staleCheckTimer) {
            clearInterval(staleCheckTimer);
            staleCheckTimer = null;
        }
    }

    // Record SSE event received (dismisses stale warning)
    function recordSseEvent() {
        lastEventTime = Date.now();
        // Hide stale warning if visible
        const els = getElements();
        if (els.staleWarningEl) {
            els.staleWarningEl.style.display = 'none';
        }
        // Update card's data attribute so parent polling can see SSE health
        if (els.cardEl) {
            els.cardEl.setAttribute('data-last-sse-event', lastEventTime.toString());
        }
    }

    // Named SSE handler function for proper cleanup
    // Use named function so we can remove it later with removeEventListener
    function handleSseMessage(event) {
        if (!event || !event.detail) return;

        // The SSE extension passes the raw event in event.detail
        const sseEvent = event.detail;

        // Record ANY SSE event (including ping) to track liveness
        recordSseEvent();

        // Handle ping (heartbeat) events - no data processing needed
        if (sseEvent.type === 'ping') {
            return; // Just update lastEventTime, no UI update
        }

        try {
            // Parse the data from the SSE event
            const data = JSON.parse(sseEvent.data);

            // Guard: only process events for this group
            if (data.group_id !== groupId) return;

            // Lookup fresh DOM elements on each event (prevents stale references)
            const els = getElements();

            // Handle init event (sent on SSE connection open)
            if (sseEvent.type === 'init') {
                // Update startTime from server's started_at
                if (data.started_at) {
                    startTime = new Date(data.started_at).getTime();
                } else {
                    // Fallback to current time if no started_at
                    startTime = Date.now();
                }

                // Update initial progress from DB
                if (data.processed !== undefined && data.total !== undefined) {
                    const percent = data.total > 0 ? Math.round((data.processed / data.total) * 100) : 0;

                    if (els.processedEl) {
                        els.processedEl.textContent = data.processed + ' / ' + data.total;
                    }
                    if (els.progressFillEl) {
                        els.progressFillEl.style.width = percent + '%';
                    }
                }

                // Handle flood_wait_until in init event
                if (data.status === 'waiting_for_accounts' && data.flood_wait_until) {
                    updateStatusBadge('waiting_for_accounts');
                    startFloodWaitCountdown(new Date(data.flood_wait_until));
                }
                return;
            }

            // Handle progress event
            if (sseEvent.type === 'progress' || !sseEvent.type) {
                // Update progress from global DB-based counts
                if (data.processed !== undefined && data.total !== undefined) {
                    const percent = data.total > 0 ? Math.round((data.processed / data.total) * 100) : 0;

                    if (els.processedEl) {
                        els.processedEl.textContent = data.processed + ' / ' + data.total;
                    }
                    if (els.progressFillEl) {
                        els.progressFillEl.style.width = percent + '%';
                    }
                }

                // Handle status transitions
                if (data.status === 'waiting_for_accounts') {
                    updateStatusBadge('waiting_for_accounts');
                    if (data.flood_wait_until) {
                        startFloodWaitCountdown(new Date(data.flood_wait_until));
                    }
                } else if (data.status === 'in_progress') {
                    // Transitioned back from waiting → in_progress
                    updateStatusBadge('in_progress');
                    hideFloodWait();
                }

                // Update status badges from breakdown
                if (data.breakdown) {
                    const badgeTypes = ['pending', 'done', 'error', 'dead'];
                    badgeTypes.forEach(badgeType => {
                        const badgeEl = document.getElementById('badge-' + badgeType + '-' + groupId);
                        if (badgeEl) {
                            const count = data.breakdown[badgeType] || 0;
                            const countEl = badgeEl.querySelector('[data-badge-count]');
                            if (countEl) {
                                countEl.textContent = count;
                            }
                            // Show/hide badge based on count
                            badgeEl.style.display = count > 0 ? 'inline' : 'none';
                        }
                    });

                    // Update error count in stats section
                    if (els.errorEl && data.breakdown.error !== undefined) {
                        els.errorEl.textContent = data.breakdown.error;
                    }
                }

                // Update current chat
                if (data.chat_title && els.currentChatEl) {
                    els.currentChatEl.textContent = data.chat_title;
                    els.currentChatEl.title = data.chat_title;
                }
            }

            // Handle error event
            if (sseEvent.type === 'error') {
                stopElapsedTimer();
                stopStaleCheckTimer();
                hideFloodWait();

                // Hide current chat on error
                if (els.currentChatEl) {
                    els.currentChatEl.textContent = '—';
                    els.currentChatEl.title = '';
                }

                // Update status badge to show error
                if (els.statusBadgeEl) {
                    els.statusBadgeEl.className = 'status-badge failed';
                    els.statusBadgeEl.textContent = 'Error';
                }

                // Show error message if provided
                if (data.error && els.errorWarningEl && els.errorMessageEl) {
                    els.errorMessageEl.textContent = data.error;
                    els.errorWarningEl.style.display = 'block';
                }

                // DO NOT trigger refreshGroups - keep card for debugging
                // User can see error state and manually refresh if needed
            }

            // Handle complete event
            if (sseEvent.type === 'complete') {
                stopElapsedTimer();
                stopStaleCheckTimer();
                hideFloodWait();

                // Hide current chat on completion
                if (els.currentChatEl) {
                    els.currentChatEl.textContent = '—';
                    els.currentChatEl.title = '';
                }

                // Trigger group refresh to show completed state
                document.body.dispatchEvent(new CustomEvent('refreshGroups'));
            }
        } catch (e) {
            console.error('Failed to parse SSE event:', e);
        }
    }

    // Listen for htmx:sseMessage events (fired by HTMX SSE extension)
    // SSE connection is now on page-level container, listen globally
    // Use signal for automatic cleanup when abortController.abort() is called
    document.body.addEventListener('htmx:sseMessage', handleSseMessage, {signal});

    // Start elapsed timer when card initializes
    startElapsedTimer();
    // Start stale check timer
    startStaleCheckTimer();

    // Cleanup on card removal (HTMX swap or DOM removal)
    // Use htmx:beforeSwap as primary cleanup - fires reliably before HTMX swaps
    function cleanupOnSwap(event) {
        // Check if the swap target is our container or parent
        if (event.detail.target && (
            event.detail.target.id === 'groups-container' ||
            event.detail.target.id === 'groups-list'
        )) {
            stopElapsedTimer();
            stopStaleCheckTimer();
            stopFloodWaitCountdown();
            // CRITICAL: Abort signal removes ALL listeners registered with this signal
            // This includes the SSE listener AND this cleanup listener
            abortController.abort();
        }
    }
    document.body.addEventListener('htmx:beforeSwap', cleanupOnSwap, {signal});

    // Fallback: MutationObserver for non-HTMX removal
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            mutation.removedNodes.forEach(function(node) {
                const els = getElements();
                if (node === els.cardEl || (node.contains && els.cardEl && node.contains(els.cardEl))) {
                    stopElapsedTimer();
                    stopStaleCheckTimer();
                    stopFloodWaitCountdown();
                    // CRITICAL: Abort signal removes ALL listeners registered with this signal
                    abortController.abort();
                    observer.disconnect();
                }
            });
        });
    });

    const initialEls = getElements();
    if (initialEls.cardEl && initialEls.cardEl.parentNode) {
        observer.observe(initialEls.cardEl.parentNode, { childList: true });
    }
})();
</script>
{% endif %}
