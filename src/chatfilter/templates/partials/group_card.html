<div class="group-card {{ group.status.value }}" id="group-{{ group.id }}"
     {% if group.status.value == 'in_progress' %}
     hx-ext="sse"
     sse-connect="/api/groups/{{ group.id }}/progress"
     {% endif %}>
    <h3>{{ group.name }}</h3>

    <span class="status-badge {{ group.status.value }}">{{ _(group.status.value) }}</span>
    {% if group.status.value == 'in_progress' %}
    <div id="stale-warning-{{ group.id }}" class="stale-warning" style="display: none; background: #fff9c4; color: #f57f17; padding: 0.5rem; border-radius: 4px; margin: 0.5rem 0; font-size: 0.875rem;">
        Нет обновлений более 60 секунд. Возможно, анализ завис.
    </div>
    {% endif %}

    <div class="group-stats">
        <div class="stat-row">
            <span>{{ _("Total chats") }}:</span>
            <strong id="total-{{ group.id }}">{{ stats.total }}</strong>
        </div>
        <div class="stat-row">
            <span>{{ _("Processed") }}:</span>
            <strong id="processed-{{ group.id }}">{{ stats.analyzed }} / {{ stats.total }}</strong>
        </div>
        <div class="stat-row">
            <span>{{ _("Failed") }}:</span>
            <strong id="failed-{{ group.id }}">{{ stats.failed }}</strong>
        </div>
        {% if group.status.value == 'in_progress' %}
        <div class="stat-row">
            <span>{{ _("Current chat") }}:</span>
            <strong id="current-chat-{{ group.id }}" class="current-chat-title">—</strong>
        </div>
        <div class="stat-row">
            <span>{{ _("Elapsed time") }}:</span>
            <strong id="elapsed-{{ group.id }}">0:00</strong>
        </div>
        {% endif %}
    </div>

    <!-- Progress bar -->
    <div class="progress-bar">
        {% set progress_pct = (stats.analyzed / stats.total * 100) if stats.total > 0 else 0 %}
        <div class="progress-fill" id="progress-fill-{{ group.id }}" style="width: {{ progress_pct }}%"></div>
    </div>

    <!-- Type breakdown -->
    <div class="type-breakdown">
        {% if stats.pending > 0 %}
        <span class="type-badge pending">{{ _("Pending") }}: {{ stats.pending }}</span>
        {% endif %}
        {% if stats.groups > 0 %}
        <span class="type-badge group">{{ _("Groups") }}: {{ stats.groups }}</span>
        {% endif %}
        {% if stats.forums > 0 %}
        <span class="type-badge forum">{{ _("Forums") }}: {{ stats.forums }}</span>
        {% endif %}
        {% if stats.channels_with_comments > 0 %}
        <span class="type-badge channel-comments">{{ _("Channels+") }}: {{ stats.channels_with_comments }}</span>
        {% endif %}
        {% if stats.channels_no_comments > 0 %}
        <span class="type-badge channel-no-comments">{{ _("Channels") }}: {{ stats.channels_no_comments }}</span>
        {% endif %}
        {% if stats.dead > 0 %}
        <span class="type-badge dead">{{ _("Dead") }}: {{ stats.dead }}</span>
        {% endif %}
        {% if stats.skipped_moderation > 0 %}
        <span class="type-badge dead" title="{{ _('These chats require approval to join. Metrics requiring join are N/A') }}">{{ _("Skipped (moderation)") }}: {{ stats.skipped_moderation }}</span>
        {% endif %}
    </div>

    <!-- Action buttons -->
    <div class="group-actions">
        <button class="btn btn-secondary btn-sm"
                hx-get="/api/groups/modal/settings/{{ group.id }}"
                hx-target="#modal-container"
                hx-swap="innerHTML">
            {{ _("Configure analysis") }}
        </button>

        {% if group.status.value == 'in_progress' %}
        <button class="btn btn-warning btn-sm"
                hx-post="/api/groups/{{ group.id }}/stop"
                hx-swap="none">
            {{ _("Stop analysis") }}
        </button>
        {% elif group.status.value == 'paused' %}
        <button class="btn btn-primary btn-sm"
                hx-post="/api/groups/{{ group.id }}/resume"
                hx-swap="none"
                hx-disabled-elt="this">
            {{ _("Продолжить анализ") }}
        </button>
        {% elif group.status.value == 'completed' %}
        <button class="btn btn-outline-secondary btn-sm"
                hx-post="/api/groups/{{ group.id }}/reanalyze?mode=increment"
                hx-swap="none"
                hx-disabled-elt="this">
            {{ _("Дополнить анализ") }}
        </button>
        <button class="btn btn-warning btn-sm"
                hx-get="/api/groups/modal/reanalyze-confirm/{{ group.id }}"
                hx-target="#modal-container"
                hx-swap="innerHTML">
            {{ _("Перезапустить анализ") }}
        </button>
        {% else %}
        <button class="btn btn-primary btn-sm"
                hx-post="/api/groups/{{ group.id }}/start"
                hx-swap="none"
                hx-disabled-elt="this">
            {{ _("Start analysis") }}
        </button>
        {% endif %}

        {% if stats.analyzed > 0 %}
        <button class="btn btn-success btn-sm"
                hx-get="/api/groups/{{ group.id }}/export/modal"
                hx-target="#modal-container"
                hx-swap="innerHTML">
            {{ _("Download results") }}
        </button>
        {% endif %}

        <button class="btn btn-danger btn-sm"
                hx-delete="/api/groups/{{ group.id }}"
                hx-swap="none"
                hx-confirm="{{ _('Delete group? This cannot be undone.') }}">
            {{ _("Delete") }}
        </button>
    </div>

    {% if error_message %}
    <script>
        ToastManager.error('{{ error_message | replace("'", "\\'") }}', {
            title: 'Cannot Start Analysis',
            duration: 8000
        });
    </script>
    {% endif %}
</div>

{% if group.status.value == 'in_progress' %}
<script>
(function() {
    const groupId = '{{ group.id }}';
    const processedEl = document.getElementById('processed-' + groupId);
    const failedEl = document.getElementById('failed-' + groupId);
    const currentChatEl = document.getElementById('current-chat-' + groupId);
    const elapsedEl = document.getElementById('elapsed-' + groupId);
    const progressFillEl = document.getElementById('progress-fill-' + groupId);
    const staleWarningEl = document.getElementById('stale-warning-' + groupId);
    const cardEl = document.getElementById('group-' + groupId);

    let startTime = Date.now(); // Will be updated from init event
    let elapsedTimer = null;
    let staleCheckTimer = null;
    let lastEventTime = Date.now();
    const STALE_THRESHOLD_MS = 60 * 1000; // 60 seconds

    // Format elapsed time as M:SS
    function formatElapsed(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return mins + ':' + (secs < 10 ? '0' : '') + secs;
    }

    // Update elapsed time every second
    function startElapsedTimer() {
        if (elapsedTimer) return; // Already running
        elapsedTimer = setInterval(function() {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            if (elapsedEl) {
                elapsedEl.textContent = formatElapsed(elapsed);
            }
        }, 1000);
    }

    function stopElapsedTimer() {
        if (elapsedTimer) {
            clearInterval(elapsedTimer);
            elapsedTimer = null;
        }
    }

    // Check for stale SSE connection (no events for >60s)
    function checkStaleConnection() {
        const timeSinceLastEvent = Date.now() - lastEventTime;
        if (timeSinceLastEvent > STALE_THRESHOLD_MS) {
            // Show stale warning
            if (staleWarningEl) {
                staleWarningEl.style.display = 'block';
            }
        }
    }

    // Start stale check timer (runs every 5s)
    function startStaleCheckTimer() {
        if (staleCheckTimer) return; // Already running
        staleCheckTimer = setInterval(checkStaleConnection, 5000);
    }

    function stopStaleCheckTimer() {
        if (staleCheckTimer) {
            clearInterval(staleCheckTimer);
            staleCheckTimer = null;
        }
    }

    // Record SSE event received (dismisses stale warning)
    function recordSseEvent() {
        lastEventTime = Date.now();
        // Hide stale warning if visible
        if (staleWarningEl) {
            staleWarningEl.style.display = 'none';
        }
    }

    // Listen for htmx:sseMessage events (fired by HTMX SSE extension)
    cardEl.addEventListener('htmx:sseMessage', function(event) {
        if (!event || !event.detail) return;

        // The SSE extension passes the raw event in event.detail
        const sseEvent = event.detail;

        // Record ANY SSE event (including ping) to track liveness
        recordSseEvent();

        // Handle ping (heartbeat) events - no data processing needed
        if (sseEvent.type === 'ping') {
            return; // Just update lastEventTime, no UI update
        }

        try {
            // Parse the data from the SSE event
            const data = JSON.parse(sseEvent.data);

            // Guard: only process events for this group
            if (data.group_id !== groupId) return;

            // Handle init event (sent on SSE connection open)
            if (sseEvent.type === 'init') {
                // Update startTime from server's started_at
                if (data.started_at) {
                    startTime = new Date(data.started_at).getTime();
                } else {
                    // Fallback to current time if no started_at
                    startTime = Date.now();
                }

                // Update initial progress from DB
                if (data.processed !== undefined && data.total !== undefined) {
                    const percent = data.total > 0 ? Math.round((data.processed / data.total) * 100) : 0;

                    if (processedEl) {
                        processedEl.textContent = data.processed + ' / ' + data.total;
                    }
                    if (progressFillEl) {
                        progressFillEl.style.width = percent + '%';
                    }
                }
                return;
            }

            // Handle progress event
            if (sseEvent.type === 'progress' || !sseEvent.type) {
                // Update progress from global DB-based counts
                if (data.processed !== undefined && data.total !== undefined) {
                    const percent = data.total > 0 ? Math.round((data.processed / data.total) * 100) : 0;

                    if (processedEl) {
                        processedEl.textContent = data.processed + ' / ' + data.total;
                    }
                    if (progressFillEl) {
                        progressFillEl.style.width = percent + '%';
                    }
                }

                // Update current chat
                if (data.chat_title && currentChatEl) {
                    currentChatEl.textContent = data.chat_title;
                    currentChatEl.title = data.chat_title;
                }
            }

            // Handle complete event
            if (sseEvent.type === 'complete') {
                stopElapsedTimer();
                stopStaleCheckTimer();

                // Hide current chat on completion
                if (currentChatEl) {
                    currentChatEl.textContent = '—';
                    currentChatEl.title = '';
                }

                // Trigger group refresh to show completed state
                document.body.dispatchEvent(new CustomEvent('refreshGroups'));
            }
        } catch (e) {
            console.error('Failed to parse SSE event:', e);
        }
    });

    // Start elapsed timer when card initializes
    startElapsedTimer();
    // Start stale check timer
    startStaleCheckTimer();

    // Cleanup on card removal (HTMX swap or DOM removal)
    // Use htmx:beforeSwap as primary cleanup - fires reliably before HTMX swaps
    document.body.addEventListener('htmx:beforeSwap', function cleanupOnSwap(event) {
        // Check if the swap target is our container or parent
        if (event.detail.target && (
            event.detail.target.id === 'groups-container' ||
            event.detail.target.id === 'groups-list'
        )) {
            stopElapsedTimer();
            stopStaleCheckTimer();
            document.body.removeEventListener('htmx:beforeSwap', cleanupOnSwap);
        }
    });

    // Fallback: MutationObserver for non-HTMX removal
    const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
            mutation.removedNodes.forEach(function(node) {
                if (node === cardEl || (node.contains && node.contains(cardEl))) {
                    stopElapsedTimer();
                    stopStaleCheckTimer();
                    observer.disconnect();
                }
            });
        });
    });

    if (cardEl && cardEl.parentNode) {
        observer.observe(cardEl.parentNode, { childList: true });
    }
})();
</script>
{% endif %}
