{% if sessions %}
{# Include modal templates #}
{% include "partials/modals/modal_code.html" %}
{% include "partials/modals/modal_2fa.html" %}
{% include "partials/modals/modal_credentials.html" %}

<div class="accounts-table-container"
     hx-ext="sse"
     sse-connect="/api/sessions/events"
     sse-swap="message"
     hx-swap="none">
    <table class="accounts-table" role="grid">
        <thead>
            <tr>
                <th scope="col">{{ _("Account") }}</th>
                <th scope="col">{{ _("Status") }}</th>
                <th scope="col">{{ _("Actions") }}</th>
            </tr>
        </thead>
        <tbody>
            {% for session in sessions %}
            <tr id="session-{{ session.session_id }}" class="account-row" data-session-id="{{ session.session_id }}">
                <td class="account-name-cell">
                    <span class="account-name">{{ session.session_id }}</span>
                </td>
                <td class="account-status-cell">
                    <span class="account-status status-{{ session.state }}"{% if session.error_message %} title="{{ session.error_message }}"{% endif %}>
                        {%- if session.state == 'disconnected' -%}
                            <span class="status-icon" aria-hidden="true">‚úì</span>
                            {{ _("Ready") }}
                        {%- elif session.state == 'connected' -%}
                            <span class="status-icon" aria-hidden="true">‚óè</span>
                            {{ _("Connected") }}
                        {%- elif session.state == 'connecting' -%}
                            <span class="status-icon spinner-small" aria-hidden="true"></span>
                            {{ _("Connecting") }}
                        {%- elif session.state == 'disconnecting' -%}
                            <span class="status-icon spinner-small" aria-hidden="true"></span>
                            {{ _("Disconnecting") }}
                        {%- elif session.state == 'banned' -%}
                            <span class="status-icon" aria-hidden="true">‚õî</span>
                            {{ _("Banned") }}
                        {%- elif session.state == 'flood_wait' -%}
                            <span class="status-icon" aria-hidden="true">‚è≥</span>
                            {{ _("Flood Wait") }}
                        {%- elif session.state == 'proxy_error' -%}
                            <span class="status-icon" aria-hidden="true">üîå</span>
                            {{ _("Proxy Error") }}
                        {%- elif session.state == 'not_configured' -%}
                            <span class="status-icon" aria-hidden="true">‚ö†</span>
                            {{ _("Not configured") }}
                        {%- elif session.state == 'proxy_missing' -%}
                            <span class="status-icon" aria-hidden="true">‚úó</span>
                            {{ _("Proxy missing") }}
                        {%- elif session.state == 'error' -%}
                            <span class="status-icon" aria-hidden="true">‚úó</span>
                            {{ _("Error") }}
                        {%- elif session.state == 'needs_code' -%}
                            <span class="status-icon" aria-hidden="true">üì±</span>
                            {{ _("Needs Verification Code") }}
                        {%- elif session.state == 'needs_2fa' -%}
                            <span class="status-icon" aria-hidden="true">üîê</span>
                            {{ _("Needs 2FA Password") }}
                        {%- elif session.state == 'needs_api_id' -%}
                            <span class="status-icon" aria-hidden="true">‚öôÔ∏è</span>
                            {{ _("Needs API ID") }}
                        {%- elif session.state == 'corrupted_session' -%}
                            <span class="status-icon" aria-hidden="true">üí•</span>
                            {{ _("Corrupted") }}
                        {%- else -%}
                            <span class="status-icon" aria-hidden="true">?</span>
                            {{ session.state }}
                        {%- endif -%}
                    </span>
                </td>
                <td class="account-actions-cell">
                    {% include "partials/session_actions.html" %}
                </td>
            </tr>
            <tr class="config-row" id="session-config-row-{{ session.session_id }}" style="display: none;">
                <td colspan="3">
                    <div class="session-config-panel" id="session-config-{{ session.session_id }}"></div>
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</div>

<script>
(function() {
    // SSE event handling: HTMX SSE extension receives HTML with hx-swap-oob="true"
    // OOB (Out-of-Band) swaps update individual session rows by ID
    // hx-swap="none" prevents replacing the container - only OOB elements are updated

    // Timeout feedback for long-running operations (10s+ shows "Still working...", 30s+ shows elapsed time)
    const operationTimers = new Map();

    function showTimeoutFeedback(element, sessionId, startTime) {
        const spinner = element.querySelector('.htmx-indicator, .spinner');
        if (!spinner) return;

        const elapsed = Math.floor((Date.now() - startTime) / 1000);

        // Create or update feedback message
        let feedback = spinner.querySelector('.operation-feedback');
        if (!feedback) {
            feedback = document.createElement('span');
            feedback.className = 'operation-feedback';
            feedback.style.marginLeft = '8px';
            feedback.style.fontSize = '0.875rem';
            feedback.style.color = 'var(--text-secondary, #666)';
            spinner.appendChild(feedback);
        }

        if (elapsed >= 30) {
            // Show elapsed time for very long operations
            feedback.textContent = `(${elapsed}s)`;
        } else if (elapsed >= 10) {
            // Show "Still working..." after 10 seconds
            feedback.textContent = '{{ _("Still working...") }}';
        }
    }

    // Start tracking operation on HTMX request
    document.body.addEventListener('htmx:beforeRequest', function(evt) {
        const element = evt.detail.elt;
        if (!element) return;

        // Only track session action buttons (Connect/Disconnect/Send Code)
        if (!element.classList.contains('session-connect-btn') &&
            !element.classList.contains('session-disconnect-btn') &&
            !element.classList.contains('session-code-modal-btn') &&
            !element.classList.contains('session-2fa-modal-btn')) {
            return;
        }

        // Find session ID
        const sessionId = element.dataset.sessionId ||
                         element.closest('[data-session-id]')?.dataset.sessionId ||
                         element.closest('[id^="session-"]')?.id.replace('session-', '');

        if (!sessionId) return;

        // Explicitly hide Connect/Disconnect buttons during operation
        if (element.classList.contains('session-connect-btn') ||
            element.classList.contains('session-disconnect-btn')) {
            element.style.display = 'none';
        }

        const startTime = Date.now();
        operationTimers.set(sessionId, {
            startTime: startTime,
            element: element,
            interval: null
        });

        // Set up interval to check elapsed time every second
        const timer = operationTimers.get(sessionId);
        timer.interval = setInterval(() => {
            showTimeoutFeedback(element, sessionId, startTime);
        }, 1000);
    });

    // Clear tracking on completion or error
    function clearOperationTimer(sessionId) {
        const timer = operationTimers.get(sessionId);
        if (timer) {
            if (timer.interval) {
                clearInterval(timer.interval);
            }

            // Clean up feedback message
            const feedback = timer.element.querySelector('.operation-feedback');
            if (feedback) {
                feedback.remove();
            }

            // Reset button visibility
            if (timer.element) {
                timer.element.style.display = '';
            }

            operationTimers.delete(sessionId);
        }
    }

    // Clear on successful response
    document.body.addEventListener('htmx:afterRequest', function(evt) {
        const element = evt.detail.elt;
        if (!element) return;

        const sessionId = element.dataset.sessionId ||
                         element.closest('[data-session-id]')?.dataset.sessionId ||
                         element.closest('[id^="session-"]')?.id.replace('session-', '');

        if (sessionId) {
            clearOperationTimer(sessionId);
        }
    });

    // Handle SSE connection errors - show persistent banner when connection drops
    document.body.addEventListener('htmx:sseError', function(evt) {
        console.error('[SSE] Connection error:', evt.detail);

        // Show persistent banner to inform user that realtime updates stopped
        if (typeof SSEStatusBanner !== 'undefined') {
            SSEStatusBanner.show();
        }

        // Also show a brief toast for immediate feedback
        if (typeof ToastManager !== 'undefined') {
            ToastManager.warning('{{ _("Connection lost. Real-time updates paused.") }}', {
                duration: 4000
            });
        }
    });

    // Toggle config panel visibility when HTMX loads content
    document.body.addEventListener('htmx:afterSwap', function(evt) {
        if (evt.detail.target.classList.contains('session-config-panel')) {
            const panel = evt.detail.target;
            const sessionId = panel.id.replace('session-config-', '');
            const btn = document.querySelector(`[data-session-id="${sessionId}"].session-config-btn`);
            const configRow = document.getElementById('session-config-row-' + sessionId);

            if (panel.innerHTML.trim()) {
                if (configRow) configRow.style.display = 'table-row';
                if (btn) btn.setAttribute('aria-expanded', 'true');
            }
        }
    });

    // Toggle panel on button click (hide if already shown)
    document.body.addEventListener('click', function(e) {
        const configBtn = e.target.closest('.session-config-btn');
        if (!configBtn) return;

        const sessionId = configBtn.dataset.sessionId;
        const panel = document.getElementById('session-config-' + sessionId);
        const configRow = document.getElementById('session-config-row-' + sessionId);

        if (panel && configRow && configRow.style.display !== 'none' && panel.innerHTML.trim()) {
            // Panel is visible, hide it
            configRow.style.display = 'none';
            panel.innerHTML = '';
            configBtn.setAttribute('aria-expanded', 'false');
            e.preventDefault();
            e.stopPropagation();
            return false;
        }
        // Otherwise let HTMX handle it (fetch and show)
    });

    // Handle HTMX errors for non-modal actions (Connect/Disconnect/Edit)
    document.body.addEventListener('htmx:responseError', function(evt) {
        const status = evt.detail.xhr?.status;
        const action = getActionName(evt.detail.elt);

        if (typeof ToastManager !== 'undefined') {
            let message;
            if (status === 500) {
                message = `{{ _("Server error while") }} ${action}. {{ _("Please try again.") }}`;
            } else if (status === 503) {
                message = `{{ _("Service temporarily unavailable while") }} ${action}. {{ _("Please try again later.") }}`;
            } else if (status >= 400 && status < 500) {
                message = `{{ _("Request failed while") }} ${action}. {{ _("Please check and try again.") }}`;
            } else {
                message = `{{ _("Network error while") }} ${action}. {{ _("Please try again.") }}`;
            }
            ToastManager.error(message, { duration: 5000 });
        }
    });

    // Handle HTMX timeout errors
    document.body.addEventListener('htmx:timeout', function(evt) {
        const action = getActionName(evt.detail.elt);

        if (typeof ToastManager !== 'undefined') {
            ToastManager.error(
                `{{ _("Request timeout while") }} ${action}. {{ _("Please check your connection and try again.") }}`,
                { duration: 5000 }
            );
        }
    });

    // Handle general HTMX errors (network failures, etc.)
    document.body.addEventListener('htmx:sendError', function(evt) {
        const action = getActionName(evt.detail.elt);

        if (typeof ToastManager !== 'undefined') {
            ToastManager.error(
                `{{ _("Connection failed while") }} ${action}. {{ _("Please check your network and try again.") }}`,
                { duration: 5000 }
            );
        }
    });

    // Handle successful action completion for Connect/Disconnect/Retry buttons
    document.body.addEventListener('htmx:afterSwap', function(evt) {
        // Only handle session row updates (not config panels or other swaps)
        if (!evt.detail.target.id || !evt.detail.target.id.startsWith('session-')) {
            return;
        }

        const triggerElement = evt.detail.elt;
        if (!triggerElement) return;

        // Determine which action succeeded based on button class
        let successMessage = null;

        if (triggerElement.classList.contains('session-connect-btn') ||
            triggerElement.closest('.session-connect-btn')) {
            // Check if it's a retry button by looking at button text or state
            const buttonText = triggerElement.textContent?.trim() || '';
            if (buttonText.toLowerCase().includes('retry') || buttonText.toLowerCase().includes('–ø–æ–≤—Ç–æ—Ä')) {
                successMessage = '{{ _("Retry initiated successfully") }}';
            } else {
                successMessage = '{{ _("Connected successfully") }}';
            }
        } else if (triggerElement.classList.contains('session-disconnect-btn') ||
                   triggerElement.closest('.session-disconnect-btn')) {
            successMessage = '{{ _("Disconnected successfully") }}';
        }

        // Show success toast if action was identified
        if (successMessage && typeof ToastManager !== 'undefined') {
            ToastManager.success(successMessage, { duration: 3000 });
        }
    });

    // Helper: Extract action name from button element
    function getActionName(element) {
        if (!element) return '{{ _("processing request") }}';

        if (element.classList.contains('session-connect-btn') ||
            element.closest('.session-connect-btn')) {
            return '{{ _("connecting") }}';
        }
        if (element.classList.contains('session-disconnect-btn') ||
            element.closest('.session-disconnect-btn')) {
            return '{{ _("disconnecting") }}';
        }
        if (element.classList.contains('session-config-btn') ||
            element.closest('.session-config-btn')) {
            return '{{ _("loading configuration") }}';
        }
        return '{{ _("processing request") }}';
    }

    // Modal button handlers
    document.body.addEventListener('click', function(e) {
        const codeBtn = e.target.closest('.session-code-modal-btn');
        if (codeBtn) {
            const sessionId = codeBtn.dataset.sessionId;
            const authId = codeBtn.dataset.authId;
            const modal = document.getElementById('code-modal');
            if (modal) {
                modal.classList.add('show');
                modal.dataset.sessionId = sessionId;
                modal.dataset.authId = authId;
                // Clear previous input and result
                const input = modal.querySelector('#code-modal-input');
                const result = modal.querySelector('#code-modal-result');
                if (input) {
                    input.value = "";
                    input.focus();
                }
                if (result) result.textContent = '';
                // Reset button state (in case it was disabled from previous submit)
                const submitBtn = modal.querySelector('#code-modal-submit');
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.textContent = '{{ _("Verify") }}';
                }
            }
            return;
        }

        const twoFaBtn = e.target.closest('.session-2fa-modal-btn');
        if (twoFaBtn) {
            const sessionId = twoFaBtn.dataset.sessionId;
            const authId = twoFaBtn.dataset.authId;
            const modal = document.getElementById('twofa-modal');
            if (modal) {
                modal.classList.add('show');
                modal.dataset.sessionId = sessionId;
                modal.dataset.authId = authId;
                // Clear previous input and result
                const input = modal.querySelector('#twofa-modal-input');
                const result = modal.querySelector('#twofa-modal-result');
                if (input) input.value = '';
                if (result) result.textContent = '';
                // Reset button state (in case it was disabled from previous submit)
                const submitBtn = modal.querySelector('#twofa-modal-submit');
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.textContent = '{{ _("Verify") }}';
                }
            }
            return;
        }
    });

    // Modal close handlers
    document.body.addEventListener('click', function(e) {
        const cancelBtn = e.target.closest('.modal-button.secondary');
        if (cancelBtn) {
            const modal = cancelBtn.closest('.modal-overlay');
            if (modal) {
                modal.classList.remove('show');
            }
        }
    });

    // Code modal submit handler
    let codeModalProcessing = false;
    document.body.addEventListener('click', async function(e) {
        const submitBtn = e.target.closest('#code-modal-submit');
        if (!submitBtn) return;

        // Prevent double-submit: check if already processing
        if (codeModalProcessing || submitBtn.disabled) {
            return;
        }

        // Set flag and disable button immediately to block rapid clicks
        codeModalProcessing = true;
        submitBtn.disabled = true;
        submitBtn.textContent = 'Verifying...';

        const modal = document.getElementById('code-modal');
        const sessionId = modal.dataset.sessionId;
        const authId = modal.dataset.authId;
        const input = modal.querySelector('#code-modal-input');
        const result = modal.querySelector('#code-modal-result');
        const code = input.value.trim();

        // Validate inputs
        if (!authId) {
            result.textContent = 'Error: auth_id not found. Please refresh and try again.';
            result.className = 'modal-result error';
            submitBtn.disabled = false;
            submitBtn.textContent = '{{ _("Verify") }}';
            codeModalProcessing = false;
            return;
        }

        if (!code) {
            result.textContent = 'Please enter the verification code.';
            result.className = 'modal-result error';
            submitBtn.disabled = false;
            submitBtn.textContent = '{{ _("Verify") }}';
            codeModalProcessing = false;
            return;
        }

        // Clear result text after validation passes
        result.textContent = '';

        try {
            // Send POST request with 10s timeout
            const formData = new FormData();
            formData.append('auth_id', authId);
            formData.append('code', code);

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000);

            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
            const response = await fetch(`/api/sessions/${sessionId}/verify-code`, {
                method: 'POST',
                body: formData,
                headers: { 'X-CSRF-Token': csrfToken },
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            const html = await response.text();

            if (response.ok) {
                // Success - update the session row and close modal
                const sessionRow = document.getElementById(`session-${sessionId}`);
                if (sessionRow) {
                    sessionRow.outerHTML = html;
                }
                modal.classList.remove('show');
                // Show success toast notification
                if (typeof ToastManager !== 'undefined') {
                    ToastManager.success('{{ _("Verification code accepted successfully") }}', {
                        duration: 4000
                    });
                }
                // Note: button stays disabled, modal closes
                codeModalProcessing = false;
            } else {
                // Error - show in modal and re-enable button for retry
                result.innerHTML = html;
                result.className = 'modal-result error';
                submitBtn.disabled = false;
                submitBtn.textContent = '{{ _("Verify") }}';
                codeModalProcessing = false;
            }
        } catch (error) {
            // Network error or timeout - re-enable button for retry
            const errorMsg = error.name === 'AbortError'
                ? 'Request timeout. Please try again.'
                : `Error: ${error.message}`;
            result.textContent = errorMsg;
            result.className = 'modal-result error';
            submitBtn.disabled = false;
            submitBtn.textContent = '{{ _("Verify") }}';
            codeModalProcessing = false;
        }
    });

    // 2FA modal submit handler
    let twofaModalProcessing = false;
    document.body.addEventListener('click', async function(e) {
        const submitBtn = e.target.closest('#twofa-modal-submit');
        if (!submitBtn) return;

        // Prevent double-submit: check if already processing
        if (twofaModalProcessing || submitBtn.disabled) {
            return;
        }

        // Set flag and disable button immediately to block rapid clicks
        twofaModalProcessing = true;
        submitBtn.disabled = true;
        submitBtn.textContent = 'Verifying...';

        const modal = document.getElementById('twofa-modal');
        const sessionId = modal.dataset.sessionId;
        const authId = modal.dataset.authId;
        const input = modal.querySelector('#twofa-modal-input');
        const result = modal.querySelector('#twofa-modal-result');
        const password = input.value;

        // Validate inputs
        if (!authId) {
            result.textContent = 'Error: auth_id not found. Please refresh and try again.';
            result.className = 'modal-result error';
            submitBtn.disabled = false;
            submitBtn.textContent = '{{ _("Verify") }}';
            twofaModalProcessing = false;
            return;
        }

        if (!password) {
            result.textContent = 'Please enter your 2FA password.';
            result.className = 'modal-result error';
            submitBtn.disabled = false;
            submitBtn.textContent = '{{ _("Verify") }}';
            twofaModalProcessing = false;
            return;
        }

        // Clear result text after validation passes
        result.textContent = '';

        try {
            // Send POST request with 10s timeout
            const formData = new FormData();
            formData.append('auth_id', authId);
            formData.append('password', password);

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000);

            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
            const response = await fetch(`/api/sessions/${sessionId}/verify-2fa`, {
                method: 'POST',
                body: formData,
                headers: { 'X-CSRF-Token': csrfToken },
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            const html = await response.text();

            if (response.ok) {
                // Success - update the session row and close modal
                const sessionRow = document.getElementById(`session-${sessionId}`);
                if (sessionRow) {
                    sessionRow.outerHTML = html;
                }
                modal.classList.remove('show');
                // Show success toast notification
                if (typeof ToastManager !== 'undefined') {
                    ToastManager.success('{{ _("2FA password accepted successfully") }}', {
                        duration: 4000
                    });
                }
                // Note: button stays disabled, modal closes
                twofaModalProcessing = false;
            } else {
                // Error - show in modal and re-enable button for retry
                result.innerHTML = html;
                result.className = 'modal-result error';
                submitBtn.disabled = false;
                submitBtn.textContent = '{{ _("Verify") }}';
                twofaModalProcessing = false;
            }
        } catch (error) {
            // Network error or timeout - re-enable button for retry
            const errorMsg = error.name === 'AbortError'
                ? 'Request timeout. Please try again.'
                : `Error: ${error.message}`;
            result.textContent = errorMsg;
            result.className = 'modal-result error';
            submitBtn.disabled = false;
            submitBtn.textContent = '{{ _("Verify") }}';
            twofaModalProcessing = false;
        }
    });
})();
</script>
{% else %}
<div class="empty-state">
    <div class="empty-state-icon">üì±</div>
    <h3>{{ _("No Telegram Accounts") }}</h3>
    <p>{{ _("You haven't added any Telegram accounts yet. Click \"Add Account\" above to get started.") }}</p>
</div>
{% endif %}
