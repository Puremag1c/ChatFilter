{% if error %}
<div class="alert alert-error">
    <div><strong>{{ error }}</strong></div>
    {% if error_action %}
    <div style="margin-top: 0.5rem; padding-left: 1rem; border-left: 3px solid rgba(255,255,255,0.3);">
        <div style="font-weight: 500; margin-bottom: 0.25rem;">{{ _("What to do:") }}</div>
        <div>{{ error_action }}</div>
    </div>
    {% endif %}
    {% if error_action_type == 'reauth' %}
    <div style="margin-top: 0.75rem;">
        <a href="/sessions" class="btn btn-sm btn-primary">
            {{ _("Go to Sessions Page") }}
        </a>
    </div>
    {% endif %}
</div>
{% else %}
<div class="analysis-progress" id="analysis-progress-{{ task_id }}" data-task-id="{{ task_id }}">
    {% if is_duplicate %}
    <div class="duplicate-notice">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10"></circle>
            <line x1="12" y1="8" x2="12" y2="12"></line>
            <line x1="12" y1="16" x2="12.01" y2="16"></line>
        </svg>
        <span>{{ _("Analysis for these chats is already in progress. Showing current status...") }}</span>
    </div>
    {% endif %}
    <div class="progress-header">
        <h4>{{ ngettext("Analyzing %(num)s chat...", "Analyzing %(num)s chats...", total_chats) }}</h4>
        <div class="progress-header-right">
            <span class="progress-status" id="progress-status">{{ _("Starting...") }}</span>
            <button id="cancel-btn" class="btn-cancel" aria-label="{{ _('Cancel analysis') }}">{{ _("Cancel") }}</button>
        </div>
    </div>

    <div class="progress-bar-container">
        <div class="progress-bar" id="progress-bar" style="width: 0%"></div>
    </div>

    <div class="progress-details">
        <span id="progress-current">0</span> / <span id="progress-total">{{ total_chats }}</span> {{ _("chats") }}
        <span id="progress-chat-title" class="current-chat"></span>
    </div>

    <div id="progress-message" class="progress-message"></div>

    <div id="analysis-result-container"></div>
</div>

<style>
.analysis-progress {
    padding: 1.5rem;
    background: #f8f9fa;
    border-radius: 8px;
    margin-top: 1rem;
}

.duplicate-notice {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    margin-bottom: 1rem;
    background: #fff3cd;
    border: 1px solid #ffc107;
    border-radius: 6px;
    color: #856404;
    font-size: 0.875rem;
}

.duplicate-notice svg {
    flex-shrink: 0;
    color: #ffc107;
}

.progress-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
}

.progress-header h4 {
    margin: 0;
    font-size: 1.1rem;
}

.progress-header-right {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.progress-status {
    font-size: 0.875rem;
    color: #666;
}

.progress-status.completed {
    color: #28a745;
    font-weight: 500;
}

.progress-status.failed {
    color: #dc3545;
    font-weight: 500;
}

.progress-status.cancelled {
    color: #ff9800;
    font-weight: 500;
}

.btn-cancel {
    padding: 0.375rem 0.75rem;
    font-size: 0.875rem;
    border: 1px solid #dc3545;
    background: white;
    color: #dc3545;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.btn-cancel:hover:not(:disabled) {
    background: #dc3545;
    color: white;
}

.btn-cancel:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.progress-bar-container {
    height: 8px;
    background: #e9ecef;
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 0.75rem;
}

.progress-bar {
    height: 100%;
    background: #2196F3;
    border-radius: 4px;
    transition: width 0.3s ease;
}

.progress-bar.completed {
    background: #28a745;
}

.progress-bar.failed {
    background: #dc3545;
}

.progress-bar.cancelled {
    background: #ff9800;
}

.progress-details {
    font-size: 0.875rem;
    color: #666;
}

.current-chat {
    margin-left: 0.5rem;
    color: #333;
    font-style: italic;
    max-width: 300px;
    display: inline-block;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    vertical-align: bottom;
}

.progress-message {
    margin-top: 0.75rem;
    font-size: 0.875rem;
    color: #666;
}

.progress-message.error {
    color: #dc3545;
}
</style>

<script>
(function() {
    const taskId = '{{ task_id }}';
    const progressBar = document.getElementById('progress-bar');
    const progressStatus = document.getElementById('progress-status');
    const progressCurrent = document.getElementById('progress-current');
    const progressTotal = document.getElementById('progress-total');
    const progressChatTitle = document.getElementById('progress-chat-title');
    const progressMessage = document.getElementById('progress-message');
    const resultContainer = document.getElementById('analysis-result-container');
    const cancelBtn = document.getElementById('cancel-btn');

    // Connection state management
    let eventSource = null;
    let pollingInterval = null;
    let reconnectAttempts = 0;
    let maxReconnectAttempts = 5;
    let isFinished = false;
    let connectionMode = 'sse'; // 'sse' or 'polling'
    let lastSeenSequence = -1; // Track sequence to ignore out-of-order events

    // Exponential backoff: 1s, 2s, 4s, 8s, 16s
    function getReconnectDelay() {
        return Math.min(1000 * Math.pow(2, reconnectAttempts), 16000);
    }

    // Update connection status in UI
    function updateConnectionStatus(status) {
        const statusMessages = {
            'connected': 'In progress...',
            'reconnecting': 'In progress (reconnecting...)',
            'polling': 'In progress (polling...)',
            'connection_lost': 'In progress (connection issues)'
        };
        if (!isFinished && statusMessages[status]) {
            progressStatus.textContent = statusMessages[status];
        }
    }

    // Handle task completion
    function handleComplete(data) {
        isFinished = true;
        cleanup();

        // Notify that analysis has stopped
        if (typeof AnalysisStateTracker !== 'undefined') {
            AnalysisStateTracker.setAnalysisRunning(false);
        }

        progressBar.style.width = '100%';
        progressBar.classList.add('completed');
        progressStatus.textContent = 'Complete!';
        progressStatus.classList.add('completed');
        progressChatTitle.textContent = '';
        progressMessage.textContent = 'Analysis complete. ' + data.results_count + ' chats analyzed.';
        cancelBtn.disabled = true;

        // Show success toast notification
        ToastManager.success('Analysis complete!', {
            title: 'Analysis Complete',
            message: data.results_count + ' chats analyzed successfully',
            duration: 5000
        });

        // Fetch and display results
        htmx.ajax('GET', '/api/analysis/' + taskId + '/results', {
            target: '#analysis-result-container',
            swap: 'innerHTML'
        });
    }

    // Handle task cancellation
    function handleCancelled(data) {
        isFinished = true;
        cleanup();

        // Notify that analysis has stopped
        if (typeof AnalysisStateTracker !== 'undefined') {
            AnalysisStateTracker.setAnalysisRunning(false);
        }

        progressBar.classList.add('cancelled');
        progressStatus.textContent = 'Cancelled';
        progressStatus.classList.add('cancelled');
        progressChatTitle.textContent = '';
        progressMessage.textContent = data.message + '. ' + data.results_count + ' chats analyzed.';
        cancelBtn.disabled = true;
        cancelBtn.textContent = 'Cancelled';

        // Fetch and display partial results if any
        if (data.results_count > 0) {
            htmx.ajax('GET', '/api/analysis/' + taskId + '/results', {
                target: '#analysis-result-container',
                swap: 'innerHTML'
            });
        }
    }

    // Handle task failure
    function handleError(errorMsg) {
        isFinished = true;
        cleanup();

        // Notify that analysis has stopped
        if (typeof AnalysisStateTracker !== 'undefined') {
            AnalysisStateTracker.setAnalysisRunning(false);
        }

        progressBar.classList.add('failed');
        progressStatus.textContent = 'Failed';
        progressStatus.classList.add('failed');
        progressMessage.textContent = errorMsg;
        progressMessage.classList.add('error');
        cancelBtn.disabled = true;
    }

    // Update progress UI
    function updateProgress(data) {
        if (data.total) {
            progressTotal.textContent = data.total;
        }

        if (data.current !== undefined) {
            const current = data.current + 1; // 0-based to 1-based
            const total = data.total;
            const percent = Math.round((current / total) * 100);

            progressBar.style.width = percent + '%';
            progressCurrent.textContent = current;
            progressTotal.textContent = total;

            if (data.chat_title) {
                progressChatTitle.textContent = '- ' + data.chat_title;
                progressChatTitle.title = data.chat_title;
            }

            if (data.message) {
                progressMessage.textContent = data.message;
            }
        }
    }

    // Cleanup connections
    function cleanup() {
        if (eventSource) {
            eventSource.close();
            eventSource = null;
        }
        if (pollingInterval) {
            clearInterval(pollingInterval);
            pollingInterval = null;
        }
    }

    // Poll for status updates
    function startPolling() {
        if (pollingInterval || isFinished) return;

        connectionMode = 'polling';
        updateConnectionStatus('polling');

        pollingInterval = setInterval(function() {
            fetch('/api/analysis/' + taskId + '/status')
                .then(r => r.json())
                .then(data => {
                    if (isFinished) {
                        cleanup();
                        return;
                    }

                    updateProgress(data);

                    if (data.status === 'completed') {
                        handleComplete(data);
                    } else if (data.status === 'cancelled') {
                        handleCancelled(data);
                    } else if (data.status === 'failed') {
                        handleError(data.error || 'Analysis failed');
                    }
                })
                .catch(err => {
                    console.error('Polling error:', err);
                    progressMessage.textContent = 'Connection issues. Retrying...';
                });
        }, 2000); // Poll every 2 seconds
    }

    // Connect to SSE with reconnection logic
    function connectSSE() {
        if (isFinished) return;

        cleanup(); // Clean up any existing connections

        try {
            eventSource = new EventSource('/api/analysis/' + taskId + '/progress');
            connectionMode = 'sse';

            eventSource.addEventListener('init', function(e) {
                const data = JSON.parse(e.data);
                // Check sequence to ignore out-of-order events
                if (data.sequence !== undefined && data.sequence <= lastSeenSequence) {
                    console.log('Ignoring out-of-order init event:', data.sequence, '(last seen:', lastSeenSequence + ')');
                    return;
                }
                if (data.sequence !== undefined) {
                    lastSeenSequence = data.sequence;
                }
                progressTotal.textContent = data.total;
                updateConnectionStatus('connected');
                reconnectAttempts = 0; // Reset on successful connection
            });

            eventSource.addEventListener('progress', function(e) {
                const data = JSON.parse(e.data);
                // Check sequence to ignore out-of-order events
                if (data.sequence !== undefined && data.sequence <= lastSeenSequence) {
                    console.log('Ignoring out-of-order progress event:', data.sequence, '(last seen:', lastSeenSequence + ')');
                    return;
                }
                if (data.sequence !== undefined) {
                    lastSeenSequence = data.sequence;
                }
                updateProgress(data);
                updateConnectionStatus('connected');
                reconnectAttempts = 0; // Reset on successful message
            });

            eventSource.addEventListener('complete', function(e) {
                const data = JSON.parse(e.data);
                // Check sequence to ignore out-of-order events
                if (data.sequence !== undefined && data.sequence <= lastSeenSequence) {
                    console.log('Ignoring out-of-order complete event:', data.sequence, '(last seen:', lastSeenSequence + ')');
                    return;
                }
                if (data.sequence !== undefined) {
                    lastSeenSequence = data.sequence;
                }
                handleComplete(data);
            });

            eventSource.addEventListener('cancelled', function(e) {
                const data = JSON.parse(e.data);
                // Check sequence to ignore out-of-order events
                if (data.sequence !== undefined && data.sequence <= lastSeenSequence) {
                    console.log('Ignoring out-of-order cancelled event:', data.sequence, '(last seen:', lastSeenSequence + ')');
                    return;
                }
                if (data.sequence !== undefined) {
                    lastSeenSequence = data.sequence;
                }
                handleCancelled(data);
            });

            eventSource.addEventListener('error', function(e) {
                let errorMsg = 'Analysis failed';
                try {
                    const data = JSON.parse(e.data);
                    // Check sequence to ignore out-of-order events
                    if (data.sequence !== undefined && data.sequence <= lastSeenSequence) {
                        console.log('Ignoring out-of-order error event:', data.sequence, '(last seen:', lastSeenSequence + ')');
                        return;
                    }
                    if (data.sequence !== undefined) {
                        lastSeenSequence = data.sequence;
                    }
                    if (data.error) {
                        errorMsg = data.error;
                    }
                } catch (err) {}
                handleError(errorMsg);
            });

            eventSource.onerror = function(e) {
                if (isFinished || eventSource.readyState === EventSource.CLOSED) {
                    return;
                }

                console.log('SSE connection error, attempt:', reconnectAttempts + 1);
                cleanup();

                // Try to reconnect with exponential backoff
                if (reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    updateConnectionStatus('reconnecting');

                    const delay = getReconnectDelay();
                    progressMessage.textContent = 'Connection lost. Reconnecting in ' + (delay / 1000) + 's...';

                    setTimeout(connectSSE, delay);
                } else {
                    // Max reconnect attempts reached, fall back to polling
                    console.log('Max SSE reconnect attempts reached, falling back to polling');
                    progressMessage.textContent = 'Connection unstable. Switched to polling mode.';
                    startPolling();
                }
            };
        } catch (err) {
            console.error('Failed to create EventSource:', err);
            // Immediate fallback to polling if SSE creation fails
            startPolling();
        }
    }

    // Cancel button handler with optimistic locking
    cancelBtn.addEventListener('click', async function() {
        // Try to acquire lock before showing confirmation
        if (typeof OptimisticLock !== 'undefined' && !OptimisticLock.tryAcquireLock('analysis', taskId, 'cancel')) {
            const lockInfo = OptimisticLock.getLockInfo('analysis', taskId, 'cancel');
            const message = lockInfo
                ? `Cancellation is already in progress in another tab (${Math.round((Date.now() - lockInfo.timestamp) / 1000)}s ago)`
                : 'Cancellation is already in progress in another tab';

            ToastManager.warning(message, {
                title: 'Operation in Progress',
                duration: 5000
            });
            return;
        }

        // Show modal confirmation
        const confirmed = await ModalManager.confirm({
            type: 'warning',
            icon: '⚠️',
            title: 'Cancel Analysis',
            message: 'Are you sure you want to cancel the analysis? The current chat will finish processing, and partial results will be saved.',
            confirmText: 'Cancel Analysis',
            cancelText: 'Continue Analysis',
            confirmClass: 'danger'
        });

        if (!confirmed) {
            // User cancelled the confirmation, release the lock
            if (typeof OptimisticLock !== 'undefined') {
                OptimisticLock.releaseLock('analysis', taskId, 'cancel');
            }
            return;
        }

        // User confirmed, proceed with cancellation
        cancelBtn.disabled = true;
        cancelBtn.textContent = 'Cancelling...';

        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;

        fetch('/api/analysis/' + taskId + '/cancel', {
            method: 'POST',
            headers: {
                'X-CSRF-Token': csrfToken
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'cancelled') {
                progressMessage.textContent = data.message;
            }
            // Release lock after successful cancellation
            if (typeof OptimisticLock !== 'undefined') {
                OptimisticLock.releaseLock('analysis', taskId, 'cancel');
            }
        })
        .catch(err => {
            console.error('Failed to cancel:', err);
            cancelBtn.disabled = false;
            cancelBtn.textContent = 'Cancel';

            // Release lock on error
            if (typeof OptimisticLock !== 'undefined') {
                OptimisticLock.releaseLock('analysis', taskId, 'cancel');
            }

            ToastManager.error('Failed to cancel analysis. Please try again.', {
                title: 'Cancellation Failed',
                duration: 8000,
                actions: [{
                    label: 'Retry',
                    class: 'retry',
                    action: 'retry',
                    callback: () => cancelBtn.click()
                }]
            });
        });
    });

    // Initial connection - check if task is already in progress (page refresh recovery)
    fetch('/api/analysis/' + taskId + '/status')
        .then(r => r.json())
        .then(data => {
            // Update UI with current state
            updateProgress(data);

            if (data.status === 'completed') {
                handleComplete(data);
            } else if (data.status === 'cancelled') {
                handleCancelled(data);
            } else if (data.status === 'failed') {
                handleError(data.error || 'Analysis failed');
            } else if (data.status === 'in_progress' || data.status === 'pending') {
                // Task is running, connect to progress stream
                // Notify that analysis is running
                if (typeof AnalysisStateTracker !== 'undefined') {
                    AnalysisStateTracker.setAnalysisRunning(true);
                }
                connectSSE();
            }
        })
        .catch(err => {
            console.error('Failed to check initial status:', err);
            // Try to connect anyway
            connectSSE();
        });

    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
        cleanup();
    });
})();
</script>
{% endif %}
